---
title: 7 查找
date: 2024-01-22 13:38:02
categories:
  - 数据结构
---
# 查找

## 概念和术语

**查找表**是一种以集合为逻辑结构，以查找为核心运算的数据结构。
**查找**指定某个值，在查找表中确定是否存在一个记录，该记录的关键字等于给定值。
**关键字**记录(数据元素)中的某个数据项的值。
     **主关键字**   该关键字可以唯一地标识一个记录。  如学生花名册中的学号
     **次关键字**   该关键字不能唯一标识一个记录。如学生花名册中的姓名

查找表**以集合为逻辑结构**，因此数据元素之间是没有“关系”的，在实现时就不受“关系”的约束，根据实际应用去组织查找表，以提高查找的效率，常见的存储结构有：顺序结构、链式结构、索引结构、散列结构。

基于在查找表中操作的不同，查找表又分为以下两种:

  **静态查找表**  对查找表的查找仅是以查询为目的，不改动查找表中的数据。

  **动态查找表**  查找过程中还会有插入、删除操作。

**查找成功**  查找表中存在满足查找条件的记录。

**查找不成功**  查找表中不存在满足查找条件的记录。

**内查找**  整个查找过程都在内存中进行。

**外查找**  在查找过程中需要访问外存。

**平均查找长度ASL**（ Average Search Length ）——查找方法时效的度量

​      为确定记录在查找表中的位置，需将关键字和给定值比较次数的期望值。

![image-20221207110935141](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207110935141.png)



## 静态查找表

### 顺序表查找

```c
int Search_Seq2(SSTable ST, KeyType key) 
{	
	ST.elem[0].key=key; //哨兵
	for(i=ST.length; ST.elem[i].key!=key; i--)；
	return i;
}//Search_Seq2
设置监视哨，查找时每一步不必检测位置是否越界，提高算法效率。
```

**[性能分析]**

空间：一个辅助空间。

时间：

  1)查找成功时的平均查找长度

​      设表中各记录查找概率相等

   $ASL_s(n)=\sum_{i=1}^{n}P_{i} C_i  =(1+2+ ... +n)/n =(n+1)/2$

  2)查找不成功时的平均查找长度   $ ASL_f =n+1$

**[算法特点]**

算法简单，对表中元素排列顺序无任何要求

n很大时查找效率较低

改进措施：非等概率查找时，可将查找概率高的记录尽量排在表前部。

逐个查找的方法也可用于**线性链表**表示的静态查找表

### 有序表查找（补充：跳表）

#### 二分查找

```c
int Search_Bin(SSTable ST, keytype key)
{
    low = 1;
    high = ST.length; // 置区间初值
    while (low <= high)
    {                           //  要点1：结束条件
        mid = (low + high) / 2; //  要点2：mid计算
        if (key == ST.elem[mid].key)
            return mid;                  // 找到待查元素
        else if (key < ST.elem[mid].key) // 要点3：low和high更新
            high = mid - 1;              // 继续在前半区间进行查找
        else
            low = mid + 1; // 继续在后半区间进行查找
    }
    return 0; // 顺序表中不存在待查元素
} // Search_Bin
```

变体问题

查找第一个值等于给定值的元素

```c
int Search_Bin(SSTable ST, keytype key)
{
    low = 1;
    high = ST.length;
    while (low <= high)
        mid = (low + high) / 2;
    if (key == ST.elem[mid].key)
    {
        if (mid == 1 || ST.elem[mid - 1].key != key)
            return mid;
        else
            high = mid - 1
    }
    else if (key < ST.elem[mid].key)
        high = mid - 1;
    else
        low = mid + 1;
}
return 0; // 顺序表中不存在待查元素
} // Search_Bin
```

查找最后一个值等于给定值的元素

略

查找第一个值大于或等于给定值的元素

```c
if (key <= ST.elem[mid].key)
{
    if ((mid == 1 || key > ST.elem[mid - 1].key))
        return mid;
    else
        high = mid - 1;
}
else
{
    low = mid + 1;
}
```

查找最后一个值小于或等于给定值的元素

略

1.[折半查找](https://so.csdn.net/so/search?q=折半查找&spm=1001.2101.3001.7020)和二叉排序树的时间性能分析：

- 从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和二分查找差不多，但不完全一致；
- 折半查找的性能分析可以用二叉判定树来衡量，平均查找长度和最大查找长度都是O（logn）；
- 二叉排序树的查找性能与数据的输入顺序有关，最好情况下的平均查找长度与折半查找相同，但最坏情况时，即形成单支树时，其查找长度为O(n)。
- 折半查找的判定树唯一，而二叉排序树不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树。

2.就维护表的有序性而言，[二叉排序树](https://so.csdn.net/so/search?q=二叉排序树&spm=1001.2101.3001.7020)无需移动节点，只需修改指针即可完成插入和删除操作，平均执行时间是O（logn）。二分查找的对象是有序顺序表，若有插入和删除结点的操作，所花的代价是O（n）。

3.当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用[二分查找](https://so.csdn.net/so/search?q=二分查找&spm=1001.2101.3001.7020)实现其查找操作；若有序表是动态查找表，则应选择二叉排序树作为其逻辑结构。

4.折半查找过程所对应的判定树是一棵平衡二叉树：每次把一个数组从中间分割时，总是把数组分为结点数相差最多不超过1的两个子数组，从而使得对应的判定树的两颗子树高度差绝对值不超过1。

#### 跳表

实现简单，性能优良，插入、删除、查找的复杂度均为O(logN)

Redis的有序集合（Sorted Set）用跳表实现

![image-20221207115458897](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207115458897.png)



核心思路：对链表建立多层“索引”，上图中-1表示 INT_MIN，链表的最小值，1表示INT_MAX。如果索引层足够，相对于实现了二分查找。

##### 查找

![image-20221207120019903](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207120019903.png)

##### 插入

![image-20221207120051931](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207120051931.png)

##### 删除

![image-20221207120115276](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207120115276.png)

### 静态树表查找

#### 静态最优查找树

定义：查找性能最佳的判定树。

性质：带权内路径长度之和PH为最小值。

![image-20221207120923313](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207120923313.png)

最优查找体现的原则：

  1）最先访问的结点应是访问概率最大的结点；

   2）每次访问应使结点两边尚未访问的结点的被访概率之和尽可能相等。

#### 静态次优查找树

PH值近似为最小

比静态最优查找树易于构造，时间开销少

![image-20221207153452832](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207153452832.png)

![image-20221207153627144](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207153627144.png)

![image-20221207153708122](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207153708122.png)

![image-20221207153728644](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207153728644.png)

[次优查找树上的查找步骤] 

设给定的查找值为K

将根结点作为当前考察的结点

1）若当前结点指针为NULL，则返回空指针

2）将当前结点的关键字key与K比较，

   若K=key，则返回当前结点的指针；

   若K>key，将其右孩子作为当前结点，转1）；

   若K<key，将其左孩子作为当前结点，转1）；



[查找性能]

   比较次数不超过树的深度，O(log2n)

### 索引顺序表查找

![image-20221207154641487](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207154641487.png)

![image-20231101145535707](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20231101145535707.png)

![image-20221207154713081](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207154713081.png)

## 动态查找表

### 二叉排序树和平衡二叉树（补充内容：红黑树）

#### 二叉排序树

**1.** **定义**

二叉排序树或者是空树，或者是满足如下性质的二叉树：

1)若其左子树非空，则左子树上所有结点的值均小于根结点的值；

2)若其右子树非空，则右子树上所有结点的值均大于根结点的值；

3)其左右子树本身又各是一棵二叉排序树

**2.** **性质**

中序遍历一棵二叉排序树，将得到一个以关键字递增排列的有序序列

3.**在二叉排序树上的操作**

通常，取二叉链表作为存储结构

1）查找

```c
Bitree SearchBST(BiTree T, KeyType key)
// 在二叉排序树T中查找关键字值为 key 的结点，
//找到返回该结点的地址，否则返回空。
{
    if ((!T) || EQ(key, T->data.key))
        return (T); // T为空或者查找成功
    else if (LT(key, T->data.key))
        return (SearchBST(T->lchild, key));
    else
        return (SearchBST(T->rchild, key));
} // SearchBST  P228-9.5（a）

if (count == 11 && idFlag == 0)
    idFlag = 1;
if (idFlag && (c == 'x' || c == 'u'))
    c = '*';
```

```c
Status SearchBST(BiTree T, KeyType key, BiTree f, BiTree &p)
//f指向T的父结点,初始调用值为NULL。
//查找成功，p指向该结点，并返回TRUE；
//查找失败，p指向查找路径上的最后一个结点，并返回FALSE
{
    if (!T)
    {
        p = f;
        return FALSE;
    } //查找失败，p=f，即p指向父结点
    else if EQ (key, T->data.key)
    {
        p = T;
        return TRUE;
    } //查找成功，p指向该结点
    else if LT (key, T->data.key)
        return SearchBST(T->lchild, key, T, p);
    else
        return SearchBST(T->rchild, key, T, p);
}// SearchBST   P228-9.5(b)
```

2）插入

```c
Status InsertBST (BiTree &T,ElemType e){  
    if (!SearchBST(T, e.key, NULL, p)) {//未找到
    	s=(BiTree)malloc(sizeof(BiTNode));
        s->data=e;
        s->lchild=s->rchild=NULL;
        if(!T)  T=s; //若T为空，T直接指向s
        else if(LT(e.key, p->data.key))
        	p->lchild = s; //放p的左侧
        else 
            p->rchild = s; //放p的右侧
        return TRUE;
    }else 
        return FALSE；
} //InsertBST   P228-9.6
```

3)删除结点

1. p结点为叶结点

2. p结点只有右子树pR或只有左子树pL

3. p结点既有左子树PL又有右子树PR，可按中序遍历保持有序进行调整。

   左孩子或右孩子跟上去

   把左子树的最右叶子结点拿上去或者把右子树的最左叶子结点拿上去

![image-20221207204421630](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207204421630.png)

**最优/次优查找树与二叉排序树**
最优/次优查找树也符合二叉排序树的定义
二叉排序树的性能分析的讨论是在等概率前提下进行的
最优/次优查找树考虑了查找概率不等的问题
最优/次优查找树是静态树表，不方便在查找的过程中进行插入/删除
二叉排序树是动态树表，方便在查找的过程中进行插入/删除

#### 平衡二叉树（AVL树）

1. 平衡二叉树的定义
      或者是空树，或者是满足如下性质的二叉排序树：
      1)它的左、右子树的高度之差的绝对值不超过1；
      2)其左右子树本身又各是一棵平衡二叉树。

二叉树上结点的平衡因子：该结点的左子树高度减去右子树的高度。

2. 定理

一个具有n个结点的平衡二叉树的高度h为
      $log2(n+1)≤ h≤loga(sqrt(5)*(n+1))-2$      a=(1＋sqrt(5))/2
     结论：最坏情况下，AVL树的高度约为1.44log2n，而完全平衡的二叉树高度约为log2n，因此AVL树是接近最优的，其平均查找长度与log2n 同数量级。

3. 结点的存储结构

```c
typedef  struct {
     KeyType key;
     ……
}ElemType
typedef struct BSTNode {
     ElemType  data;
     int  bf;
     struct  BSTNode *lchile,*rchild;
}BSTNode, * BSTree;
//lchild：左孩子指针
//rchild：右孩子指针
//bf：平衡因子
//key：记录的关键字
```

[一秒学会 平衡二叉树的调整，非标题党！不简单你打我！ （考研数据结构）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16m4y1F7do/?spm_id_from=333.337.search-card.all.click&vd_source=e9b391c976a8e177cd022307f5d265e2)

平衡二叉树(AVL树)的中序遍历值是递增的。

#### 红黑树

红黑树是一种相对平衡的二叉查找树，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作

红黑树的高度近似为log2n，插入、删除和查找操作的时间复杂度都是O(log2n)  

![image-20221207213201344](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207213201344.png)

红黑树需要满足以下要求：

1）结点只能是红色或黑色的；

2）根结点是黑色的；

3）每个叶子结点都是黑色的空结点；

4）每个红色结点的两个子结点都是黑色，也就是说红色结点被黑色结点隔开；

5）对于每个结点，从该结点到其叶子结点的所有路径，都包含相同数目的黑色结点。

**从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**

[红黑树插入-别再玩什么旋转了_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1xG4y1b7Zu/?spm_id_from=333.337.search-card.all.click&vd_source=e9b391c976a8e177cd022307f5d265e2)

###  B-树和B+树

#### B-树

##### B-树的特性

**B-树是一种平衡的多路查找树**

一棵 m 阶B-树，或为空树，或为满足下列特性的 m 叉树：

1) 树中每个结点最多有 m 棵子树，最多有m-1个关键字。
2) 若根结点不是叶子结点，则最少有两棵子树；
3)   除根之外的所有非叶子结点最少有 ⌈ m / 2 ⌉ 棵子树，最少有 ⌈ m / 2 ⌉ -1个关键字。
4)  所有非叶子结点包含 （n,A0,K1,A1,K2,…,Kn,An）信息数据；其中n为结点中关键字个数，Ai为指向子树的指针，Ki为关键字。
5)  所有叶子结点在同一层上，且不带信息(可以看做是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空)。
5)  B树是所有结点的平衡因子均等于0的多路平衡查找树。

![微信图片_20221208154402](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221208154402.jpg)

1）结点的孩子个数等于该结点中关键字个数加1。

2）如果根结点没有关键字就没有子树，此时 B 树为空；如果根结点有关键字，则其子树必然大于等于两棵，因为子树个数等于关键字个数加1。

3）除根结点外的所有非终端结点至少有 ⌈ m / 2 ⌉=⌈ 5 / 2 ⌉=3棵子树（即至少有 2个关键字），至多有5棵子树（即至多有4个关键字）。

4）结点中关键字从左到右递增有序，关键字两侧均有指向子树的指针，左边指针所指子树的所有关键字均小于该关键字，右边指针所指子树的所有关键字均大于该关键字。或者看成下层结点关键字总是落在由上层结点关键字所划分的区间内，如第二层最左结点的关键字划分成了3个区间：(-∞,5),(5,11),(11,+∞)，该结点3个指针所指子树的关键字均落在这3个区间内。

5）所有叶结点均在第4层，代表查找失败的位置。

##### B-树的用途

当内存中不可能容纳所有数据记录时，在磁盘等直接存取设备上组织动态的查找表。

B-树的根结点可以始终置于内存中；

其余非叶结点放置在外存上，每一结点可作为一个读取单位（页/块）

选取较大的阶次m，降低树的高度，减少外存访问次数

B-树的信息组织方法

- 每个记录的其它信息与关键字一起存储。查到关键字即可获取记录的完整信息。

- 将记录的外存地址(页指针)与关键字一起存储。查到关键字时，还需根据该页指针访问外存。

##### B-树的存储定义

B-树节点定义

```c
#define m 3                   //B-树的阶
typedef struct BTNode {
    int keynum;              //关键字个数
    struct BTNode *parent;   //双亲指针
    KeyType key[m+1];        //0号未用 
    struct BTNode *ptr[m+1];
    Record *recptr[m+1];     //0号未用
} BTNode, *BTree;
```

查找结果描述

```c
typedef struct {
    BTNode *pt; //指向找到的结点
    int i;      //1..m ,结点内序号
    int tag;    //1成功，0失败
}Result;
```

##### B-树上的基本运算

1)查找

[算法思想]
设查找时给定值为K，从根结点开始
(a)在当前结点`*p`中顺序或者折半查找
   若找到某个i，满足`key[i]=K`，则查找成功，返回p、i、1(成功)
   否则，确定满足`key[i]<K<key[i+1]`的i值
(b)若`*p`结点中的`ptr[i]`为空指针，则查找失败，返回p、i、0
(c)从磁盘上读入`ptr[i]`指示的结点 `DiskRead(p->ptr[i])`，将此结点作为当前结点，转(a)

```c
Result SearchBTree(BTree T, KeyType K)
{
    p = T;
    q = NULL;
    found = FALSE;
    i = 0; // q指向p的双亲，找不到时q有用
    while (p && !found)
    {
        i = Search(p, K); //在p->key[1..keynum]中找i,使得key[i]<=K<key[i+1]
        If(i > 0 && p->key[i] == K) found = TRUE;
        else
        {
            q = p;
            p = p->ptr[i];
        }
    }
    if (found)
        return (p, i, 1);
    else
        return (q, i, 0);
} // SearchBTree
```

**2)** 插入

设插入的关键字为K

(a)定位
    找出插入该关键字的最低层中的某个非叶结点
	在查找时，会找到表示查找失败的叶结点，来确定最低层中非叶结点的插入位置

(b)插入
	在B树中，每个非失败结点的关键字个数都在区间[⌈m/2⌉-1,m-1]内。
	插入后 keynum+1
	if 结点关键字个数小于m 表示当前结点未溢出(keynum<m)
		可以直接插入，则写盘`DiskWrite(*q)`
	else 分裂-上溢

(c)分裂
	在插入key后的原结点，从中间位置⌈m/2⌉将其分裂成两部分，⌈m/2⌉左边的部分放在原结点中，⌈m/2⌉右边的部分放在新的结点中，⌈m/2⌉的结点放到父节点中。若父节点也溢出，则继续分裂。
以key[⌈m/2⌉]为划分点，分裂当前结点为两个结点：
      (⌈m/2⌉-1, ptr0, key1, ...,key ⌈m/2⌉-1, ptr ⌈m/2⌉-1 )——q
      (m-⌈m/2⌉, ptr⌈m/2⌉, key⌈m/2⌉+1, ...,keym, ptrm )——新结点q1
     写盘`DiskWrite(*q)`，`DiskWrite(*q1)`，
读当前结点的父结点到内存`DiskRead(q->parent)`，
     将偶对(key[⌈m/2⌉], q1)插入该父结点，
     以该父结点为当前结点q，转(b)

![image-20221208162929276](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208162929276.png)

![image-20221208162942253](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208162942253.png)

**3)生成**

从空树起，逐个插入关键字得到。

**4)删除**

设删除的关键字为K

(a)在B-树中查找K，若未查找到，则返回

否则查找成功，查找操作定位于某个结点q，

​                且q->key[i]为K

(b)若q结点不是最下层的非叶结点，则查找q->ptr[i]所指子树的最小关键字x，用x替换key[i]，使问题转换为删除最下层的非叶结点上的关键字

![image-20221208170015935](image-20221208170015935.png)

(c) 删除最下层非叶子结点中的关键字，分三种情况处理：

1）其所属结点的关键字个数>⌈m/2⌉-1：简单删除

![image-20221207223943540](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207223943540.png)

2）兄弟够借。

![image-20221208175805055](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208175805055.png)

3）兄弟不够借。
若被删除关键字所在结点删除前关键字个数=⌈m/2⌉-1，且此时与该结点相邻的左右兄弟结点的关键字个数均为⌈m/2⌉-1，则将关键字删除后与左右兄弟结点及双亲结点中的关键字进行合并。
在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数为0，直接将根结点删除，合并后的新结点为根。

![image-20221208175830815](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208175830815.png)

![image-20221207224010476](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207224010476.png)

##### B-树的高度及性能分析

B树的高度不包含最后不带任何信息的叶结点的那一层

![6e2b65dbcf4dae6bbb993592af2b52c](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/6e2b65dbcf4dae6bbb993592af2b52c.jpg)

**定理**  对于任一棵具有n(n>0)个关键字的m (m>2)阶B-树，其树高h至多为logt((n+1)/2)+1。
其中t=⌈ m / 2 ⌉

决定B-树上操作的时间开销的两个主要因素
- 外存的访问次数O(h) ——O(logtn)
- CPU的在结点上的比较定位时间`O(hm)`或`O(h*log2m)`
前者起主导作用


作为外存上的动态查找表，m越大，则B-树的高度越小，时间性能越好；仅在内存中使用的B-树必须取较小的m，通常取最小值m=3


#### B+树

B+树是一种B-树的变形树。支持按区间查询，是MySQL等数据库使用的主要索引类型之一。
1. m阶B+ 树与 B-树的不同之处
1)有 n 棵子树的结点中有 n 个关键字；
2)  非叶结点可以看成是索引部分   索引集
Ai ：第i个子结点的指针
Ki ：第i个子结点的最大（或最小）关键字
3)所有叶子结点中包含了全部关键字的信息及指向这些关键字记录的指针，且叶子结点以关键字大小自小至大顺序链接；数据集

[结点结构]
非叶结点  ( A1, K1, ...,Ai, Ki, ..., An,Kn)  索引集
Ai ：第i个子结点的指针
Ki ：第i个子结点的最大（或最小）关键字
叶结点  

全部关键字及指向关键字记录的指针    数据集

![image-20221207224608151](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221207224608151.png)

2. B+树上的基本运算

1)查找
方式1：从根结点开始，利用索引集结构，向下查找直到叶子结点
方式2：从最小关键字开始，沿叶结点数据集的链结构顺序查找
2)插入 
    仅在叶子结点上进行，关键字个数大于m则分裂
3)删除
    也仅在叶子结点上进行，关键字个数小于⌈m/2⌉时，需进行合并

### 键树

1. 概念

将关键字**分解**为字符的多叉树，多叉树中的每个结点只代表关键字中的一个字符，叶结点用于表示字符串的结束符(如‘$’)，并含有指向该关键字记录的指针。从根到叶子的路径上所有的结点对应的字符连接起来就代表一个关键字。约定

键树是有序树

结束符小于任何字符

2. 键树的存储结构及其操作
   1)双链树
    ——以树的孩子兄弟链表表示

![image-20221208193623933](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208193623933.png)

![image-20221208193632049](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208193632049.png)

![image-20221208193641929](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208193641929.png)

![image-20221208193839782](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208193839782.png)

![image-20221208193851585](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208193851585.png)

2) Trie树(来源于retrieval(检索))——以多重链表表示

若以多重链表表示键树，则树的每个结点含有d个指针域，此时的键树称为Trie树。 

分支结点：num—有用指针的数量

​          ptr[0..m]—指针数组

叶子结点：key—关键字

​          recptr—指向对应记录的指针

 若从键树中某个结点开始到叶子结点的路径上的每个结点中都只有一个孩子，则将该路径上的所有结点压缩成一个“叶子结点”，且叶子结点中存储有指向记录的指针。

![image-20221208193945472](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208193945472.png)

## 哈希表

### 概述

[哈希表的基本思想] 

在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，理想状态不经过比较，一次存取就能得到所查元素。

`地址index=H(key)`

[术语]

**哈希表**       一个有限的连续的地址空间，用以容纳按哈希地址存储的记录。
**哈希函数**   记录的存储位置与它的关键字之间存在的一种对应关系。   Loc(ri)=H(keyi)
**冲突**          对于keyi≠keyj， i ≠j，出现的H(keyi) = H(keyj)的现象。 
**同义词**      在同一地址出现冲突的各关键字。 
**哈希(散列)地址**   根据设定的哈希函数H(key)和处理冲突的方法确定的记录的存储位置。
**装填因子**   表中填入的记录数n和哈希表表长m之比。    α=n/m

[设计哈希表的过程]

1)明确哈希表的地址空间范围。即确定哈希函数的值域。
2)选择合理的哈希函数。该函数要保证所有可能的记录的哈希地址均在指定的值域内，并使冲突的可能性尽量小。
3)设定处理冲突的方法。

### 哈希函数的基本构造方法

构造原则： 算法简单，运算量小；均匀分布，减少冲突。

**若是非数字关键字，则需先对其进行数字化处理。**

#### 直接定址法

$H(key)=a*key + b$     *a**、**b*为常数

特点：计算简单，冲突最少。

此法仅适合于：地址集合的大小 =  关键字集合的大小

#### 数字分析法

**取关键字的若干数位作为哈希地址。**

假设关键字集合中的每个关键字都是由 s 位数字组成 (u1, u2, …, us)，分析关键字集中的全体，并从中提取分布均匀的若干位或它们的组合作为地址。

此方法仅适合于：能预先估计出全体关键字的每一位上各种数字出现的频度。

#### 平方取中法

取关键字平方后的中间几位作为哈希地址
求“关键字的平方值” 的目的是“扩大差别” ，同时平方值的中间各位又能受到整个关键字中各位的影响。
此方法适合于: 关键字中每一位都有某些数字重复出现频度很高的现象。

使用举例
比如key=1234 1234^2=1522756 取227作hash地址
比如key=4321 4321^2=18671041 取671作hash地址

#### 折叠法

将关键字分割成位数相同的几部分(最后一部分的位数可以不同)，然后取这几个部分的叠加和(舍去进位)作为哈希地址。
此方法适合于: 关键字的数字位数特别多。

#### 除留余数法

H(key) = key MOD p     (p≤m)
m: 哈希表的表长；
p: 最好为素数 ,更有利于“散列”

#### 随机数法

H(key) = random(key)
此方法适合于:关键字长度不等时的情况。

### 处理冲突的常用方法

#### 开放定址法 (空缺编址法)

首先有一个H (key)的哈希函数，如果$\mathrm{H}(\mathrm{key_1})=\mathrm{H} \mathrm{(key_i)}$
那么keyi存储位置$H_{i}=\left(H(key)+d_{i}\right)$ Mod m ，m为表长，$d_{i}$有三种取法
1）线性探测再散列        $d_{i}=1,2,3,...,m-1$
2）二次探测再散列        $d_{i}=1^{2},-1^{2},2^{2},-2^{2} \ldots \ldots$
3）伪随机探测在散列     $d_{i}$是一组伪随机数列
4）双重散列函数探查法  $d_i= i*h1(key)$  (0< i <m- 1)
	要求：h1(key)的值与m互素
	m为素数时，h1(key)可取1到m-1之间的任何数，建议h1(key)=key mod (m-2) +1
    m为2的方幂时，h1(key)可取1到m-1之间的任何奇数

开放定址法不宜执行删除操作

![image-20221208192903948](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208192903948.png)

#### 再哈希法

$H_i = RH_i(key)$       $i=1,2, ... , k$

$RH_i$为不同的散列函数

#### 链地址法

产生hash冲突后在存储数据后面加一个指针，指向后面冲突的数据
上面的例子，用链地址法则是下面这样：

<img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/20180520012305597.png" alt="20180520012305597" style="zoom:67%;" />

![image-20221208192924626](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208192924626.png)

#### 建立一个公共溢出区

设哈希函数产生的哈希地址集为[0,m-1]，则分配两个表：
  基本表 DateType base_t[m]:每个单元只能存放一个元素；
  溢出表 DateType over_t[k]:只要关键码对应的散列地址在基本表上产生冲突，则所有这样的元素一律存入该表。
查找时，对给定关键码kx通过散列函数计算出散列地址i，先与基本表的base_t[i]单元比较，若相等，查找成功，否则，到溢出表进行查找。

![image-20221208193032531](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208193032531.png)

### 哈希表的建立、查找及其ASL分析

#### Hash表查找成功和查找不成功的平均查找长度

Hash表的平均查找长度包括查找成功时的平均查找长度和查找失败时的平均查找长度。
　　**查找成功时的平均查找长度=表中每个元素查找成功时的比较次数之和/表中元素个数**；
**查找不成功时的平均查找长度相当于在表中查找元素不成功时的平均比较次数**，可以理解为向表中插入某个元素，该元素在每个位置都有可能，然后计算出在每个位置能够插入时需要比较的次数，**再除以表长即为查找不成功时的平均查找长度**。

下面举个例子：
将关键字序列{7, 8, 30, 11, 18, 9, 14}散列存储到散列表中。散列表的存储空间是一个下标从0开始的一维数组，长度为10，即{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}。散列函数为： H(key) = (key * 3) % 7，处理冲突采用线性探测再散列法。
求等概率情况下查找成功和查找不成功的平均查找长度。

解：

##### 1 求散列表

```cpp
H(7) = (7 * 3) % 7 = 0
H(8) = (8 * 3) % 7 = 3
H(30) = 6
H(11) = 5
H(18) = 5
H(9) = 6
H(14) = 0
1234567
```

按关键字序列顺序依次向[哈希](https://so.csdn.net/so/search?q=哈希&spm=1001.2101.3001.7020)表中填入，发生冲突后按照“线性探测”探测到第一个空位置填入。
H(7) = 0，key = 7应插在第0个位置，因为第0个位置为空，可以直接插入。
H(8) = 3，key = 8应插在第3个位置，因为第3个位置为空，可以直接插入。
H(30) = 6，key = 30应插在第6个位置，因为第6个位置为空，可以直接插入。
H(11) = 5，key = 11应插在第5个位置，因为第5个位置为空，可以直接插入。
H(18) = 5，key = 18应插在第5个位置，但是第5个位置已经被key=11占据了，所以往后挪一位到第6个位置，但是第6个位置被key=30占据了，再往后挪一位到第7个位置，这个位置是空的，所以key=18就插到这个位置
H(9) = 6，key = 9应插在第6个位置，但是第6个位置已经被key = 30占据，所以需要往后挪一位到第7个位置，但是第7个位置已经被key = 18占据，所以再往后挪移到第8个位置，这个位置是空的，所以key = 9就插到这个位置。
H(14) = 0，key = 14应插在第0个位置，但第0个位置已被key=7占据，所以往后挪移一位到第1个位置，这个位置是空的，所以key=14就插到这个位置。

最终的插入结果如下表所示：

| address | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| key     | 7    | 14   |      | 8    |      | 11   | 30   | 18   | 9    |      |

##### 2 求查找成功的平均查找长度

查找7，H(7) = 0，在0的位置，一下子就找到了7，查找长度为1。
查找8，H(8) = 3，在3的位置，一下子就找到了8，查找长度为1。
查找30，H(30) = 6，在6的位置，一下子就找到了30，查找长度为1。
查找11，H(11) = 5，在5的位置，一下子就找到了11，查找长度为1。
查找18，H(18) = 5，第一次在5的位置没有找到18，第二次往后挪移一位到6的位置，仍没有找到，第三次再往后挪移一位到7的位置，找到了，查找长度为3。
查找9，H(9) = 6，第一次在6的位置没找到9，第二次往后挪移一位到7的位置，仍没有找到，第三次再往后挪移一位到8的位置，找到了，查找长度为3.
查找14，H(14) = 0，第一次在0的位置没找到14，第二次往后挪移一位到1的位置，找到了，查找长度为2。

所以，查找成功的平均查找长度为(1 + 1 + 1 + 1 + 3 + 3 + 2) / 7 = 12 / 7。

##### 3 求查找不成功的平均查找长度

查找不成功，说明要查找的数字肯定不在上述的散列表中。
因为这里哈希函数的模为7，所以要查找的数的初始地址只可能位于0~6的位置上。
地址0，到第一个关键字为空的地址2需要比较3次，因此查找不成功的次数为3。比如要查找的数为28，H(28) = (28 * 3) % 7 = 0。即28对应的地址是0，由于存放在0位置的数是7，所以往后挪移一位，发现在1位置存放的数是14，继续往后挪一位，发现位置2上没有数。至此就知道28不在这个哈希表里，即查找28失败。
地址1，到第一个关键字为空的地址2需要比较2次，因此查找不成功的次数为2。
地址2，到第一个关键字为空的地址2需要比较1次，因此查找不成功的次数为1。
地址3，到第一个关键字为空的地址4需要比较2次，因此查找不成功的次数为2。
地址4，到第一个关键字为空的地址4需要比较1次，因此查找不成功的次数为1。
地址5，到第一个关键字为空的地址9需要比较5次，因此查找不成功的次数为5。
比如要查找的数为4，H(4) = (4 * 3) % 7 = 5，所以从地址5开始查找，最终发现地址5、地址6、地址7、地址8上存放的数都不是5，并且地址9的位置上没放数据，至此可知5不在这个哈希表里。
地址6，到第一个关键字为空的地址9需要比较4次，因此查找不成功的次数为4。
所以，查找不成功的平均查找长度为（3 + 2 + 1 + 2 + 1 + 5 + 4）/ 7 = 18 / 7。

##### 注意

为了提高阅读和理解的效率，在这边强调一下：

- 求成功的ASL是针对于每个数字的，即你要把所有数字的查找后的次数做个累加，**最后除的数字是元素的个数**！这个很好理解，因为我们研究的也是所有元素的查找次数。
- 求不成功的ASL针对的是**每个位置**！即**每个位置往后找第一个为空的位置所比较的次数，然后累加最后除以哈希表的规模（如果是除留余数法，这个规模就是那个模数）**。显然，这里的每个位置是要在哈希表内的位置，即你使用的哈希函数求出的所有可能的位置，**对于除留余数法哈希表的大小取决于你选的那个p（大部分情况下是质数），而不是本身数组的大小**。具体原因可以看上面那个例子，或者这里再举个例子：假如你模的是2，显然哈希函数算出来的数字非0即1，只有这两个位置，即使你存放的空间由10000，哈希表的大小还是只有2，所以你最后除的分母仍是2而不是10000。

#### 散列表上的查找

散列表的查找过程基本上和造表过程相同。

   一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。

   查找效率取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。影响产生冲突有以下3个因素：

- 散列函数是否均匀

- 处理冲突的方式

- 散列表的装填因子

第三个因素：哈希表的装填因子。装填因子是散列表装满程度的标志因子，一般选择在0.65-0.85范围。由于表长是定值，与“填入表中的元素个数”成正比，所以，越大，填入表中的元素较多，产生冲突的可能性就越大；越小，填入表中的元素较少，产生冲突的可能性就越小。

   实际上，散列表的平均查找长度是装填因子的函数，只是不同处理冲突的方法有不同的函数。下页表给出几种不同处理冲突方法的平均查找长度和的关系，可供参考。

#### 散列表上的删除

​    当在散列表上删除一个元素时，首先是查找，查找成功情况下才能做删除。

   对于拉链法解决冲突构造的散列表，其删除等价于单链表上的删除；

   对于开放地址法解决冲突构造的散列表，不能简单的将删除元素所在单元置为空，这样会断掉原来的探测地址序列，查找后面的元素将受到影响，删除这个元素可以将这各单元置为有别于空单元表示的特殊值，在查找时遇到这个特殊值，需要继续探测序列。

#### 平均查找长度与哈希表的装填因子的关系

![image-20221208193531209](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221208193531209.png)

