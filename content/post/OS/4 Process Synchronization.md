---
title: 4 Process Synchronization
categories:
  - OS
date: 2023-10-21 21:19:31
tags:
---

# Process Synchronization

## Background

### Bounded-Buffer Procedure-Consumer Problem

Bounded-Buffer Procedure-Consumer Problem（有界缓冲程序-消费者问题）是一个经典的并发编程问题，通常用于展示多进程/多线程同步和互斥的概念。问题的背景通常是一个有界缓冲区，其中生产者生产项目并将其放入缓冲区，而消费者则从缓冲区中取出项目并进行处理。

以下是问题的要点和解决方法：

问题描述：
1. 有一个固定大小的缓冲区，可以容纳有限数量的项目。
2. 生产者进程生产项目并尝试将其放入缓冲区。
3. 消费者进程从缓冲区中取出项目并进行处理。
4. 缓冲区在满时不允许生产者继续生产，当缓冲区为空时不允许消费者继续消费。

解决方法： 问题通常通过使用互斥锁（mutex）和条件变量（condition variable）来解决。这些是线程同步的工具，用于确保生产者和消费者之间的正确互斥操作。
1. 互斥锁：用于保护共享缓冲区，以确保在任何时刻只有一个线程可以访问它。
2. 条件变量：用于通知其他线程缓冲区的状态，如是否为空或已满。

解决方法的关键点：
- 当缓冲区满时，生产者会等待，直到有空间可用。
- 当缓冲区为空时，消费者会等待，直到有项目可用。
- 当生产者放置项目或消费者取出项目后，它们会通知其他等待的线程。

这样，通过互斥锁和条件变量的协同作用，可以实现生产者和消费者之间的正确同步，确保没有数据竞争或死锁。

## The Critical-Section Problem

The Critical-Section Problem（临界区问题）是并发编程中的一个经典问题，通常用于展示如何实现多个进程或线程之间的互斥访问共享资源。问题的核心是多个进程（或线程）需要同时访问共享资源，但要确保它们不会在同一时间访问该资源，以避免数据竞争和不一致性。

**概念：**
1. 同步：指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。
2. 互斥：当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。

**问题描述：**
1. 多个进程或线程需要访问一个共享资源，如共享内存区域、全局变量或文件。
2. 任何时刻，只允许一个进程/线程访问共享资源，其他进程/线程必须等待。
3. 进程/线程必须在进入临界区（临界区是访问共享资源的代码段）之前获得访问权限，然后在退出临界区后释放访问权限。

**解决方法：**
问题通常通过使用互斥锁（mutex）和信号量（semaphore）等同步工具来解决。这些工具用于确保只有一个进程/线程可以进入临界区，而其他进程/线程必须等待。

**临界区资源访问过程：**
1. **Entry Section**
   - 进程发送请求以获取许可或锁，以指示其希望进入临界区域。
   - 检查是否可进入临界区
2. **Critical Section**
   - 临界部分通常包括需要保护的关键代码，以确保数据一致性。
3. **Exit Section**
   - 在退出部分，进程释放许可或锁，以允许其他进程进入临界区域。
   - 进程也可以执行一些清理操作或更新共享数据。
4. **Remainder Section**
   - 在完成退出部分后，进程可以执行其余下部分的代码，这些代码通常不需要互斥保护。

**Solution must satisfy three requirements**
1. **互斥**
   - 同一时刻只能有一个进程在其关键部分执行。
2. **空闲让进**
   - 进展性确保如果当前没有进程在其关键部分执行，而有些进程希望进入其关键部分，那么选择下一个进入关键部分的进程不应无限期地被延迟。
3. **有限等待**
   - 有界等待对其他进程在允许一个进程请求进入其关键部分并在该请求获得批准之前进入其关键部分的次数设置了限制。
   - 这一要求旨在防止其他进程不断地超越某个进程，确保进程执行的公平性。

 **竞争条件：** 
 竞争条件是指多个进程或线程试图同时访问共享资源，可能导致数据不一致或其他问题。在操作系统中，一些潜在的竞争条件包括管理文件、内存分配、进程列表维护以及中断处理等方面。
- **抢占式和非抢占式：** 处理竞争条件的方法取决于操作系统是否支持抢占。
	- 抢占式操作系统允许内核模式下的进程被抢占，这可能导致在多处理器系统中难以设计，因为两个内核模式进程可能在不同处理器上同时运行。
	- 非抢占式操作系统在内核模式下一直运行，直到它退出内核模式、阻塞或自愿放弃 CPU。这种情况下，内核模式下几乎没有竞争条件。

## Peterson’s Solution

Peterson 算法是基于双线程互斥访问的LockOne与LockTwo算法而来。LockOne算法使用一个 flag 布尔数组，LockTwo 使用一个 turn的整型量，都实现了互斥，但是都存在死锁的可能。Peterson 算法把这两种算法结合起来，完美地用软件实现了双线程互斥问题。

首先，我们来看看下面这段代码：

```c
Pi进程：                                                                    
flag[i] = True;
while(flag[j]);
critical section;
flag[i] = False;
remainder section; 

Pj进程：                                                               
flag[j] = True;
while(flag[i]);
critical section;
flag[j] = False;
remainder section;
```

以上是用来实现两个进程互斥访问临界区的两端代码，我们可以这样来理解这两段代码，其中`flag[i]`表示进程Pi表示想要进入临界区，`while(flag[j])`可以理解为Pi在自己进临界区之前，先问问Pj是否想要进入临界区，如果Pj想进的话它就等待（Pi品德高尚）；类似的，Pj也是同样的。双方互相谦让的结果是，最终两个进程谁也进不了临界区。（可以想象这样一个生活场景，两个人同时想进屋，结果在门口谦让了了半天，过了很久都没进去）

Peterson算法就是在上面代码的基础之上，又引入了一个变量turn，打破了这种因为谦让而导致“饥饿”的现象。下面我们先来看看Peterson算法的代码：

```c
Pi进程：                                                                   
flag[i] = True;
turn = j;
while(flag[j] && turn == j);
critical section;
flag[i] = False;
remainder section;

Pj进程：                                                                   
flag[j] = True;
turn = i;
while(flag[i] && turn == i);
critical section;
flag[j] = False;
remainder section;
```

怎么理解变量turn呢？可以将turn变量理解成轮到谁进入临界区了。举个例子：turn = i，表示轮到Pi进入临界区。那么上面这个代码就可以理解为：首先，Pi想进入临界区（`flag[i] = True`），然后，还是和前面的代码一样，Pi会先把进入临界区的机会让给Pj（`turn = j`），同样地，当Pj想进入临界区时，也会将进入临界区的权利先让给Pi。紧接着，变量turn的作用就显现出来了，当Pj把进入临界区的机会又让给Pi的时候（注意：这是发生在Pi将进入临界区的优先权让给Pj之后），Pi这次就会直接进入临界区。就不会再次出现一直互相谦让，最终导致均无法进入临界区的情况了。

关于为什么当进入临界区的权利（即turn = i）又回到Pi手里时，Pi会直接进入临界区的分析？我们可以分析一下Pi能够成功进入临界区的条件（即：`while(flag[j] && turn == j`)语句）：
总的分为以下两种情况：
1. Pj不想进入临界区（`flag[j] = False`）
	当Pj不想进入临界区时，自然也就不存在Pi和Pj冲突的情况，Pi当然就直接进入临界区。
2. Pj想进入临界区（`flag[j] = True`）
	当Pj想进入临界区，又分为以下两种情况：
	- 当 turn = i
		turn = i说明当前轮到i进入临界区了 ，这个时候i就直接进入临界区了，不再谦让。（其实这个挺合理的，根据Peterson算法的代码我们不难发现因为turn的值是根据先后想要进入临界区的顺序排列的）
	- 当 turn != i
		turn != i 说明当前轮到i进入临界区了没有轮到Pi进入临界区，Pi自然需要等待。

仅过上面的分析，我们就不难理解，当Pi和Pj经过一轮谦让之后，就会直接根据turn的值（即：该轮到谁进临界区了）来直接决定谁该进入临界区。现在回过头回顾整个算法，其实我们会发现，Peterson算法的思想会更贴近于生活中的真实情况，大家一般都是略微谦让一下，然后直奔主题，难道不是吗？哈哈

## \*Bakery Algorithm

面包店算法为n个进程的临界区问题提供了一种解决方案。在进入临界区之前，每个进程都会接收到一个编号。持有最小编号的进程首先进入临界区。如果两个进程Pi和Pj接收到相同的编号，那么比较它们的进程ID：如果i<j，则Pi先被服务；否则Pj先被服务。编号方案始终按枚举的递增顺序生成编号，例如1, 2, 3, 3, 3, 3, 4, 5等等。

这里的“<”表示字典顺序（票号，进程ID号）。如果(a, b)<(c, d)，那么要么是a<c，要么在a=c的情况下b<d。max(a0, …, an-1)是一个数字k，满足对于所有i = 0, …, n – 1，k≥ai。

```c
Shared data
boolean choosing[n];//false
int number[n]; //0

Pi
while (1) {
	choosing[i] = true; // Pi is taking a number
	number[i] = max(number[0], number[1], …, number [n–1])+1; //排队取号
	choosing[i] = false; // end of number taking
	for (j = 0; j < n; j++) {
		while (choosing[j]) ;
		while ((number[j] != 0) && ((number[j], j)<(number[i], i)); //排队等待
	}
	critical section
	number[i] = 0;
	remainder section
}
```

## Synchronization Hardware

### Synchronization Hardware

许多系统提供硬件支持以保护临界区代码。

- **禁用中断disable interrupts**
	- 在单处理器系统中，当前正在执行的代码可以在不被抢占的情况下执行。而在多处理器系统中，这种做法效率太低，时间成本很高。这也会影响系统时钟的精度，特别是当时钟的更新是通过中断来完成的。
- **锁（Lock）**：一个简单的工具，用于实现互斥。
	- 进程在进入临界区之前必须获取一个锁。
	 - 当进程退出临界区时，它会释放锁，使其他进程能够进入。
- **atomic hardware instructions** 现代计算机提供特殊的原子硬件指令，这些指令是不可中断的。
	- **原子操作（Atomic）** 意味着操作过程不会被中断。
	- 例如，**TestAndSet()** 指令用于测试内存单元的值并设置新的值。
	- **Swap()** 指令用于交换两个内存单元的内容。

![image-20231109193936288](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20231109193936288.png)

这些原子硬件指令可以在多线程或多进程的情况下，用来保护临界区代码，确保多个执行单元在同时访问共享资源时不会发生竞争条件。这些原子指令提供了一种有效的方式来执行互斥操作，而无需禁用中断或使用锁。

### Solution using TestAndSet()

使用 `TestAndSet()` 来解决临界区问题的解决方案如下：

```c
Shared data:
boolean lock = FALSE;

Process Pi
while(TRUE) {
    while (TestAndSet(&lock));
    critical section
    lock = FALSE;
    remainder section
}
```

- 共享数据：`boolean lock = FALSE;`，`lock` 是一个布尔变量，初始值为 `FALSE`。
- 进程 `Pi`：
  1. 进入一个无限循环，表示一直在运行。
  2. 在进入临界区之前，使用 `TestAndSet(&lock)` 来测试并设置 `lock`，如果 `lock` 的值为 `TRUE`，则继续等待，直到 `lock` 变为 `FALSE`。
  3. 一旦获得了 `lock`，进入临界区执行临界区代码。
  4. 执行完临界区后，将 `lock` 设置为 `FALSE`，表示离开了临界区。
  5. 最后，执行剩余部分。

这个解决方案使用 `TestAndSet()` 指令来确保在一个时刻只有一个进程能够进入临界区，其他进程必须等待。这样，它满足了互斥性的要求。

### Solution using Swap()

使用 `Swap()` 来解决临界区问题的解决方案如下：

```c
Shared data:
boolean lock = FALSE;

Process Pi
while(TRUE) {
    key = TRUE;
    while (key == TRUE)
        Swap (&lock, &key);
    critical section
    lock = FALSE;
    remainder section
}
```

- 共享数据：`boolean lock = FALSE;`，`lock` 是一个布尔变量，初始值为 `FALSE`。
- 进程 `Pi`：
  1. 进入一个无限循环，表示一直在运行。
  2. 首先将 `key` 设置为 `TRUE`。
  3. 在进入临界区之前，使用 `Swap(&lock, &key)` 将 `lock` 和 `key` 互换，如果 `lock` 的值是 `TRUE`，那么 `key` 的值将变成 `TRUE`，表示继续等待。如果 `lock` 的值是 `FALSE`，那么 `key` 的值将变成 `FALSE`，表示进入临界区。
  4. 一旦获得了锁，进入临界区执行临界区代码。
  5. 执行完临界区后，将 `lock` 设置为 `FALSE`，表示离开了临界区。
  6. 最后，执行剩余部分。

这个解决方案使用 `Swap()` 指令来确保在一个时刻只有一个进程能够进入临界区，其他进程必须等待。这样，它满足了互斥性的要求。

### Mutual Exclusion Machine Instructions

**优势：**

- 适用于任意数量的进程，无论是在单处理器还是在共享主内存的多处理器系统上。
- 简单，易于验证。
- 可用于支持多个临界区。

**劣势：**

- <u>**Busy-waiting**</u>会占用处理器时间，这可能会导致资源的浪费。
- 可能出现<u>**starvation**</u>情况，当一个进程离开临界区并且有多个进程在等待时。
- <u>**deadlock**</u>：如果一个优先级较低的进程拥有临界区，而一个优先级较高的进程需要进入临界区，那么高优先级的进程将获得处理器，但它只是等待临界区。

### Revised Solution Using TestAndSet()

经过修订的使用TestAndSet()的解决方案如下：

```c
Shared data(initialized to FALSE) : 
boolean lock;
boolean waiting[n];

Process Pi 
while (TRUE)
{
    waiting[i] = TRUE;
    key = TRUE;
    while (waiting[i] && key)
        key = TestAndSet(&lock);
    waiting[i] = FALSE;
    // critical section
    j = (i + 1) % n;
    while ((j != i) && !waiting[j])
        j = (j + 1) % n;
    if (j == i)
        lock = FALSE;
    else
        waiting[j] = FALSE;
    // remainder section
}
```

**共享数据（初始化为FALSE）：**

- boolean lock; // 用于表示临界区是否被锁定
- boolean waiting[n]; // 用于表示每个进程是否在等待

这是使用TestAndSet()进行修订的解决方案，以实现多个进程之间的互斥。当进程需要访问临界区时，它首先等待其他进程完成，然后尝试使用TestAndSet()获取锁。在进入临界区后，它会检查是否有其他进程在等待，如果没有，就释放锁；否则，将等待标志设置为FALSE，以允许其他进程尝试获取锁。这有助于确保只有一个进程可以同时进入临界区。

### Mutex Locks

以前的硬件解决方案复杂且通常不易被程序员所使用，操作系统设计者通过编写软件工具来解决关键段问题。最为简单的解决方案是互斥锁（又称互斥机制）。
保护关键段的方法是：首先获取（acquire）锁，然后释放（release）锁。
采用一个布尔变量available来表示锁的状态，用以判断锁是否可用。
acquire()和release()锁的操作必须是原子性的，通常通过硬件原子指令来实现原子性操作。
然而，这种解决方案需要忙等待，即在获取锁时，线程需要不断尝试直到锁可用。因此，这种锁被称为<u>自旋锁（spinlock）</u>。自旋锁通常在多处理器系统中使用，以解决多个处理器同时访问共享资源的问题。

```c
acquire()
{
    while (!available)
      ; /* busy wait */
    available = false;
}
release()
{
    available = true;
}
```

## Semaphores

信号量（Semaphore）是一种用于进程同步的工具，它提供了比互斥锁更复杂的方法。与互斥锁不同，信号量不需要busy waiting。
信号量是一个特殊的变量，通常用**整数**来表示，可以初始化为非负数。它只能通过两个不可分割的操作来访问：

1. `wait(S)`：等待操作，用于获取信号量，操作会减小信号量的值。S--
2. `signal(S)`：信号操作，用于释放信号量，操作会增加信号量的值。S++
这两个操作是不可中断的，它们在执行过程中不会被中断。
信号量用于实现进程同步和互斥，它可以帮助控制多个进程之间的访问共享资源的顺序。

### Semaphore usage
信号量的使用可以分为两种主要类型：二进制信号量和计数信号量。
#### Binary Semaphore
- 整数值只能在 0 和 1 之间取值。
 - 通常用于互斥控制，类似于互斥锁（Mutex Lock）。
 - 一个进程可以通过 `wait(S)` 操作获取二进制信号量，使其值变为 0，表示资源已被占用。
- 通过 `signal(S)` 操作释放二进制信号量，使其值变为 1，表示资源可用。
#### Counting Semaphore
   - 整数值可以在一个不受限制的范围内取值。
   - 通常用于控制对一组有限数量资源的访问。
   - 计数信号量的初始值通常设置为资源的可用数量。
   - 当一个进程希望使用资源时，它执行 `wait()` 操作，减小信号量的值。
   - 当一个进程释放资源时，它执行 `signal()` 操作，增加信号量的值。
   - 当计数信号量的值降至 0 时，表示所有资源都被使用，此后希望使用资源的进程将会被阻塞，直到计数信号量的值再次大于 0。

为了确保 wait() 和 signal() 操作的原子性：

在单处理器系统中，通常的做法是在执行这些操作时禁止（抑制）中断。这样可以防止进程在执行这些操作时被中断，从而保证了操作的原子性。

- [ ] 在多处理器系统中，禁止中断并不是一个可行的解决方案，因为即使在一个处理器上禁止了中断，其他处理器上的进程仍然可以执行这些操作。因此，需要使用锁定技术来确保操作的原子性。一个常见的锁定技术是使用自旋锁（spinlocks），它会让进程在尝试获取锁时循环检查锁是否可用，而不是放弃处理器的控制权。



计数信号量可用于控制对共享资源的并发访问，确保资源在同一时刻不被过多的进程使用。

在解决临界区问题时，信号量可以用来协调多个进程的访问。下面是一个关于 n 个进程的临界区问题的示例，以及如何使用信号量来同步它们的执行：

```plaintext
Critical Section of n Processes

Shared data:
semaphore mutex; // 初始值为 1

Process Pi:
while (true) {
    wait(mutex);
    // 临界区代码
    signal(mutex);
    // 剩余部分代码
}
```

在此示例中，有 n 个进程（P1, P2, ..., Pn），它们共享一个信号量 `mutex`，它的初始值为 1。每个进程在进入临界区之前都会执行 `wait(mutex)` 操作，以等待获取信号量。当一个进程完成临界区的操作后，它会执行 `signal(mutex)` 操作，释放信号量，允许其他进程进入临界区。

这种方式可以确保在同一时刻只有一个进程能够进入临界区，从而避免了竞争条件。但需要注意的是，如果某个进程在等待获取信号量时，它会处于忙等待状态，这可能会浪费 CPU 资源。这种类型的信号量也被称为自旋锁（spinlock），因为进程在等待锁时会自旋（忙等待）。

此外，示例中的 `n` 可以是任意正整数，表示有多少个进程需要协调访问临界区。

在信号量的实现中，可以使用等待队列来避免忙等待。信号量可以被定义为一个 C 结构，每个信号量具有以下属性：

- 一个整数值，表示信号量的计数。
- 一个进程列表（等待队列），用于存储等待获取信号量的进程。

信号量操作包括：

- `block()`: 当一个进程调用此操作时，它会被放置到适当的等待队列中，表示它正在等待获取信号量。
- `wakeup(P)`: 当需要释放信号量时，可以从等待队列中选择一个等待的进程，并将其移至就绪队列，以便它可以继续执行。

这种方式允许进程在等待信号量时不会浪费 CPU 资源，因为它们不需要忙等待。相反，它们会进入等待队列，直到信号量可用，然后才会被移至就绪队列。

这种信号量的实现方式更高效，特别适用于多进程协同工作的情况，以避免资源竞争和提高系统的整体性能。

这是一个使用等待队列的信号量实现，其中包括 `wait` 和 `signal` 操作。以下是这两个操作的伪代码示例：

`wait` 操作:

```c
wait(semaphore *S) {
    S->value--;  // 减少信号量值
    if (S->value < 0) {
        // 如果信号量值小于零，表示资源不可用，将当前进程加入等待队列并阻塞
        add this process to S->List;
        block();  // 阻塞当前进程
    }
}
```

`signal` 操作:

```c
signal(semaphore *S) {
    S->value++;  // 增加信号量值
    if (S->value <= 0) {
        // 如果信号量值不小于零，表示有等待的进程，唤醒其中一个
        remove a process P from S->List;
        wakeup(P);  // 唤醒一个等待的进程
    }
}
```

这种实现方式可以确保在资源不可用时，等待的进程不会浪费 CPU 资源，而是会被阻塞，直到资源可用。一旦资源可用，信号量会唤醒一个等待的进程，使其可以继续执行。这有助于避免忙等待，提高系统的效率和性能。

这个信号量实现采用了等待队列，以确保没有两个进程可以同时执行相同信号量上的 `wait()` 和 `signal()` 操作。为了避免竞态条件，必须确保这两个操作在临界区内执行。

具体实现的方式取决于系统的特性：

- 在单处理器系统中，可以通过禁用中断来防止进程切换，从而实现临界区的互斥。
- 在多处理器系统中，需要使用锁定技术，如自旋锁（spinlocks），以确保 `wait()` 和 `signal()` 操作在同一信号量上不会同时执行。

虽然这种实现方式并没有完全消除忙等待，但它将忙等待限制在 `wait()` 和 `signal()` 操作的关键部分。由于这两个操作的实现代码很短（通常不超过10条指令），因此关键部分很少被占用，因此忙等待发生得很少。

这种方法允许系统高效地等待资源的可用性，同时尽量减少不必要的忙等待。这有助于提高系统性能和效率。

问题：死锁和饥饿

1. **死锁**：指两个或多个进程无限期地等待一个只能由等待中的进程中的一个触发的事件。死锁是并发系统中的一种严重问题。

   示例：假设有两个信号量S和Q，它们都被初始化为1。

   ```
   P0                          P1
   wait (S);                   wait (Q);
   wait (Q);                   wait (S);
   …                           …
   signal (Q);                 signal (S);
   signal (S);                 signal (Q);
   ```

   在这个示例中，P0和P1都试图以相反的顺序等待S和Q，这可能导致死锁。

2. **饥饿**：饥饿是指进程无限期地被阻塞。这种情况下，进程可能永远无法从其挂起的信号量队列中被移除。饥饿可能导致一些进程无法获得所需的资源，从而降低系统性能。

   示例：一个使用LIFO（后进先出）队列的信号量可能导致某些进程永远无法获得资源，因为它们总是排在队列的末尾。

这些问题是在并发编程中需要小心处理的关键问题。解决方法包括使用适当的算法和数据结构，以及在设计时考虑进程的优先级和资源分配策略，以避免死锁和饥饿的发生。

### Priority Inversion

- **定义**：优先级反转是指在多任务系统中，当一个具有较低优先级的任务持有一个较高优先级任务所需的资源时，可能导致高优先级任务受阻的情况。
- **例子**：
	- 假设有三个进程，分别为L、M和H：
	- H（高优先级）需要资源R，而L（低优先级）正在使用该资源。因此，H必须等待L完成对R的使用。
	- 在此时，M（中等优先级）可以运行，并抢占了L的执行。
	- 此时，由于M的运行，L被抢占，导致H等待更长时间才能获得对R的访问。这种情况称为优先级反转，因为高优先级的任务被低优先级的任务所阻塞。
- **solution**：优先级继承协议priority-inheritance protocol
	- 当一个任务（例如L）持有一个资源（例如R）时，任何试图访问这个资源的任务都会继承该任务的优先级（例如H的优先级）。
	- 在上述例子中，L在使用R期间临时继承了H的优先级，以确保H不会被低优先级的M所阻塞。
	- 一旦任务完成对资源的使用，它的优先级就会恢复到原始值。

## Classic Problems of Synchronization
### The Bounded-Buffer Problem
有界缓冲区问题
假设缓冲池由 n 个缓冲区组成，每个缓冲区可以容纳一个项目。
共享数据包括三个信号量：mutex、empty 和 full。
初始状态如下：
- mutex = 1：互斥信号量，确保每次只有一个进程能够进入临界区。
- empty = n：表示空缓冲区的数量，初始时所有缓冲区都是空的。
- full = 0：表示已满缓冲区的数量，初始时没有缓冲区是满的。

<img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20231031091453749.png" alt="image-20231031091453749" style="zoom:25%;" />

有界缓冲区问题的解决方案通常包括生产者和消费者两个进程。生产者负责将产品放入缓冲区，而消费者从中获取产品。这里的代码示例描述了生产者和消费者的基本循环：

![image-20231031091742133](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20231031091742133.png)

公有信号量-互斥

私有信号量-同步

### The Readers-Writers Problem

竞争：读-写、写-写
共享：读-读

有两个经典的读者-写者问题：

第一个读者-写者问题（**读者优先**）：
- 只有读取内容的读者和可以更新内容的写者。
- 读者可以同时访问共享对象。
- 写者具有独占访问共享对象的权限。
- 在这个问题中，没有读者会一直等待，除非有一个写者已经获得了访问共享对象的权限。
- 写者可能会饥饿，即等待时间较长。

![image-20231031092629701](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20231031092629701.png)

rw-mutex是读写的互斥信号量，mutex_r是控制读者数量的信号量。
先等能控制读者数量的时候，如果有个读者进程出现，就会让read_count的数量++，如果是第一个读者，要等rw_mutex信号量为1的时候才能进行下一步。
当最后一个读者读完了，要把rw_mutex信号量释放

第二个读者-写者问题（写者优先）：
- 一旦写者准备好，它将尽快执行写入。
- 如果有一个写者正在等待访问共享对象，那么新的读者将无法开始阅读。
- 在这个问题中，读者可能会饥饿，因为一旦写者准备好，读者将无法访问共享对象。

### The Dining-Philosophers Problem

这是著名的"哲学家就餐问题"（Dining Philosophers Problem）的示例，通常用于说明并发编程中的同步和资源分配问题。在这个问题中，有五位哲学家坐在一张圆形餐桌周围，每位哲学家面前放着一只筷子。他们交替地思考（thinking）和进餐（eating），但只有在同时拿到两只筷子时才能进餐。解决这个问题需要协调哲学家的活动，以避免死锁和竞态条件。

在这个示例中，`semaphore chopstick[5]` 是五个信号量，代表五只筷子。每位哲学家都需要拿起两只相邻筷子才能吃饭。解决方案的核心是确保一位哲学家在拿筷子时不会与其邻居发生竞争。

哲学家的活动循环包括以下部分：
1. 思考（thinking）：哲学家在思考时不需要资源，因此直接进入思考状态。
2. 饥饿（hunger）：哲学家想要进餐，但必须获取两只筷子。他们通过等待两只相邻筷子的信号量来表示他们的饥饿。
3. 进餐（eating）：当哲学家拿到两只筷子后，他们可以进餐。进餐后，他们释放筷子。

```c
semaphore chopstick[5]={1,1,1,1,1};

//Pi
while(1){
	hunger
	wait(chopstick[i]);
	wait(chopstick[(i+1)%5]);
	eating
	signal(chopstick[i]);
	signal(chopstick[(i+1)%5]);
	thinking
}
```

solution1
最多4个人吃饭，至少有一只筷子多出来
增加一个count信号量
```c
semaphore chopstick[5]={1,1,1,1,1};
semaphore count=4;

//Pi
while(1){
	hunger
	wait(count);
	wait(chopstick[i]);
	wait(chopstick[(i+1)%5]);
	eating
	signal(chopstick[i]);
	signal(chopstick[(i+1)%5]);
	signal(count);
	thinking
}
```

solution2
奇数拿左边，偶数拿右边
如果拿不到就吃不上，等下次再拿

```c
semaphore chopstick[5]={1,1,1,1,1};

//Pi
while(1){
	hunger
	if(i%2==1){
		wait(chopstick[i]);
		wait(chopstick[(i+1)%5]);
	}else{
		wait(chopstick[(i+1)%5]);
		wait(chopstick[i]);
	}
	eating
	signal(chopstick[i]);
	signal(chopstick[(i+1)%5]);
	thinking
}
```

## Monitors
### Define Monitor

**Monitors**（管程）是一种高级同步构造，用于在并发进程之间安全共享抽象数据类型。Monitor是一个软件模块，通常用于控制对共享资源的访问，以避免竞态条件和确保数据的一致性。

- **局部数据变量**: 
  - 这些变量仅限于Monitor内部的过程访问。
- **进程入口**:
  - 进程通过调用Monitor中的某个过程来进入。
- **互斥执行**:
  - 任何时候，Monitor内只允许一个进程执行。

一个Monitor的概念示意图如下：

```
+------------------------+
|      Monitor         |
|                      |
|   Data Variables     |
|                      |
|   Procedures         |
|                      |
|   Condition Variables|
|                      |
+------------------------+
```

上面的示意图展示了一个监视器的基本结构。监视器内部包括以下主要组成部分：
1. 数据变量（Data Variables）：这些是局部数据变量，只能由Monitor内的过程访问。它们用于存储Monitor所管理的共享数据。
2. 过程（Procedures）：这些是Monitor内定义的过程，通常用于对共享数据进行操作。只有进入Monitor的进程才能调用这些过程。
3. 条件变量（Condition Variables）：条件变量是一种用于等待和通知的机制。它们允许进程在满足某些条件之前等待，然后在条件满足时被通知继续执行。条件变量通常与等待（wait）和通知（signal）操作相关联。

### Condition Variable

条件变量（Condition Variable）是管程（Monitor）内的一个重要组成部分，用于实现进程的等待和通知机制。条件变量通常与等待（wait）和通知（signal）操作相关联。
1. 声明条件变量：在monitor内，你可以声明一个或多个条件变量`condition x, y;`
2. wait() 操作：调用此操作的进程将被挂起（suspended），直到另一个进程调用x.signal();
3.  signal() 操作：恢复（resumes）一个被挂起的进程。如果没有进程被挂起，则signal操作没有任何效果。

条件变量和相关操作使监视器内的进程能够更灵活地协同工作，等待特定条件的满足，并在条件满足时得到通知。这有助于避免忙等待（busy waiting）和提高系统的效率。不同编程语言和操作系统可能会提供不同的条件变量实现，但它们的基本概念是相似的。
