---
title: 5  Deadlocks
categories:
  - OS
date: 2023-10-21 21:27:13
tags:
---

# Deadlocks
## System Model
1. Resource types：系统中有多种资源类型，包括 CPU、内存空间、文件、I/O 设备（如打印机等）。
2. 资源可以分为**物理资源**和**逻辑资源**。  
   - physical resources：preemptive resources，如 CPU、内存；non-preemptive resources，如打印机。  
   - logical resources：temporary resources, known as consumable resources
3. 资源实例：每个资源类型都有若干个实例。
4. 进程如何使用资源：每个进程根据其需求请求、使用和释放资源。
5. system table：系统表记录了每个资源的状态（自由或分配），以及若资源分配给哪个进程。
6. 请求、使用和释放：进程在需要资源时发起请求，获得资源后进行使用，并在完成任务后释放资源。
## Deadlock Characterization
死锁特征是指一组进程在运行过程中，由于资源争用导致的一种特殊状态，即这些进程都在等待对方释放资源，从而导致进程无法继续执行。

死锁的特征主要包括以下几点：
1. 互斥性：至少有两个进程在争夺同一资源，且至少有一个进程已经持有了该资源。
2. 请求与等待：进程请求获取它所需要的资源，但该资源已被其他进程占用，因此请求进程处于等待状态。
3. 不可剥夺性：已分配给进程的资源在未被该进程释放前，其他进程无法强行占用。
4. 循环等待：存在一个进程链，每个进程都在等待下一个进程所持有的资源。
当以上特征同时满足时，系统就容易出现死锁现象。理解死锁特征有助于分析和预防死锁的发生，从而确保系统资源的合理分配和进程的正常运行。
### Resource-Allocation Graph
资源分配图是一种用于描述多个进程在请求和分配资源过程中的关系图表。
在资源分配图中，每个进程用一个节点表示，每条边表示一个进程请求或分配一个资源。
1. 节点V：图表中的节点代表进程。每个节点包含当前进程已经分配的资源数量以及尚未请求的资源数量。
  1. P表示进程
  2. R表示资源
2. 边E：图表中的边表示进程之间的资源请求关系。边有两种类型： 
   - 请求边request edge：表示一个进程可能请求另一个进程所持有的资源。请求边用虚线表示。  
   - 分配边assignment edge：表示一个进程已经分配了某个资源。分配边用实线表示。
3. 循环：在资源分配图中，如果存在一个进程链，每个进程都在等待下一个进程所持有的资源，那么就形成了循环等待。循环等待是导致死锁的一个关键条件。
  1. 循环在资源分配图中起着关键作用，可以用来判断系统是否会发生死锁。当循环中每个资源类型只有一个实例时，系统必然会发生死锁。而当循环中的资源类型有多个实例时，虽然死锁的可能性较高，但并非必然发生死锁。
4. 安全状态与不安全状态：
	- 安全状态是指不存在循环等待的情况下，系统可以分配资源给进程而不会导致死锁。
	- 不安全状态是指存在循环等待，系统分配资源可能导致死锁的情况。
    通过检查资源分配图中的循环等待，系统可以确定哪些资源分配是安全的，哪些是不安全的。在不安全情况下，系统可以采取措施推迟进程的资源分配，直到资源请求不会导致死锁。

![image-20231031082908858](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20231031082908858.png)

## Methods for Handling Deadlocks
-  死锁预防 Deadlock-prevention：通过制定严格的资源请求顺序，预先避免死锁的发生。例如，为所有资源类型设定一个全局排序，并要求进程按照资源编号的升序请求资源。  
- 死锁避免 Deadlock-avoidance：在系统运行过程中，通过检测潜在的死锁情况并采取措施避免它们。例如，使用银行家算法（Banker Algorithm）来预先分配资源，确保不会发生资源请求冲突。
- 允许系统进入死锁状态，检测到死锁后进行恢复（Deadlock Detection and Recovery）：  
  - 检测：通过一定的算法和策略检测到系统中的死锁情况。  
  - 恢复：当死锁发生时，通过终止进程、抢占资源或回滚进程状态等方法解除死锁。
- 忽略问题（Deadlock Ignoration）：假装死锁在系统中永远不会发生。大多数操作系统（包括 UNIX 和 Windows）都采用这种方法。

## Deadlock Prevention
- 互斥性（Mutual Exclusion）是指对于不可共享的资源，进程之间需要相互排斥，确保同一时间只有一个进程可以使用该资源；而对于可共享的资源，则不需要互斥性。
- 持有等待（Hold and Wait）意味着进程在请求新资源时，不能持有其他资源。
	- 这里提供了两种持有等待的策略：
		- 进程在开始执行前，需要请求并分配所有所需资源。但这种方法的缺点是资源利用率低。
		- 只在进程没有资源时才请求资源（先释放资源）。但这种方法的缺点是可能导致进程饥饿（starvation）。
- 不预先分配资源（No Preemption）。
	- 该策略有两种实现方式：
		- 当一个进程请求资源时，其已经持有的资源会被抢占。进程必须在没有资源的情况下等待。
			- 如果一个持有资源的进程请求一个无法立即分配的资源，那么它将释放当前持有的所有资源。
			- 被抢占的资源会被添加到进程等待的资源列表中。
		- 进程在持有资源的情况下等待，但持有的资源可能会被其他请求这些资源的进程抢占。
			- 这种策略通常适用于状态容易保存和恢复的资源，如 CPU 寄存器和内存空间。
- 循环等待（Circular Wait）。该策略要求对所有资源类型进行 total 排序，并规定每个进程按资源类型请求的顺序递增。
	- 每个资源的排序位置由 F(Ri) 确定。
	-  该策略有两种实现方式：  
		- 进程可以请求资源类型 Rj 的实例，条件是 F(Rj) > F(Ri)。如果需要多个相同资源类型的实例，进程必须一次请求所有实例。  
		  - 每当进程请求资源类型 Rj 的实例时，它需要释放任何 F(Ri) ≥ F(Rj) 的资源。
		  这样可以确保系统在资源分配时遵循一定的顺序，从而降低死锁的可能性。
## Deadlock Avoidance
每个进程声明可能需要的每种资源的最大数量。
死锁避免算法动态检查资源分配状态，以防止循环等待条件出现。
资源分配状态包括可用资源、已分配资源和进程的最大需求。
### Safe State
 安全状态（Safe State）是指在系统中，所有进程都能够继续执行，且不会发生死锁的状态。在安全状态下，系统的资源分配满足以下条件：
1. 对于每个进程 Pi，其尚未请求到的资源可以通过当前可用的资源加上所有进程 Pj（其中 j<i）已持有的资源来满足。  
2. 如果某个进程需要的资源暂时不可用，那么该进程需要等待，直到所有进程 Pj 完成任务。  
3. 当一个进程完成任务后，它释放已持有的资源，然后继续执行下一个任务。
### Resource-Allocation Graph Algorithm
资源分配图算法被用来检测系统是否处于**安全状态**，以避免死锁的发生。
该算法主要应用于**单实例资源分配**系统，通过分析资源分配图，判断资源分配是否会导致死锁。
1. 创建一个资源分配图，其中节点表示进程，边表示进程对资源的请求，框里点的个数表示资源个数。  
2. 使用深度优先搜索（DFS）或广度优先搜索（BFS）算法检测图中是否存在循环。  
	1. 如果no circle，说明系统处于安全状态，一定没有死锁，可以进行资源分配。  
	2. 如果找到循环，说明系统处于不安全状态，此时进程必须等待其他进程释放资源以避免死锁。
		1. 如果每个资源类型只有一个实例，并且这个实例被循环中的进程所持有，那么就会发生死锁。
		2. 如果循环中涉及到的每个资源类型都有多个实例，那么可能会发生死锁。
			1. 在这种情况下，尽管图中存在循环，这表明至少有一个进程在等待另一个进程释放资源，但由于每个资源类型有多个实例，因此理论上，如果循环中的进程能够获取到它们需要的资源的一个替代实例，那么死锁可以避免。因此，循环是死锁存在的必要条件，但不是充分条件。即使存在循环，只要资源分配得当，死锁是可以避免的。

"一个实例"通常指的是一种特定类型的资源的单个副本。假设有一个资源类型是“打印机”，那么系统中可能会有多台打印机。

在资源分配图算法中，进程请求资源的过程如下：
1. 进程 Pi 请求资源 Rj。  
2. 检查将 Pi → Rj 转换为 Rj → Pi 是否会导致图中的循环。  
7. 如果没有导致循环，则允许资源分配，进程继续执行；否则，进程 Pi 需要等待。

![](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/20240105120908.png)
### Banker’s Algorithm
银行家算法（Banker's Algorithm），它适用于**多个实例的资源分配系统**。进程需要在事先声明它们可能需要的**每种资源的最大数量**。当进程请求一组资源时，系统必须检查分配这些资源是否会使得系统处于安全状态。如果可以，则分配资源；否则，进程必须等待其他进程释放足够的资源。当进程获得所有所需资源后，它必须在有限的时间内归还这些资源。
 银行家算法所需的数据结构:
1. n：表示进程的数量。  
2. m：表示资源类型的数量。
以下是数据结构的具体组成部分：
1. Available：一个长度为 m 的向量。如果 `Available[j] = k`，意味着有 k 个 Rj 类型的资源可用。  
2. Max：一个 n×m 的矩阵。如果 `Max[i, j] = k`，表示进程 Pi 最多可能请求 k 个 Rj 类型的资源。  
3. Allocation：一个 n×m 的矩阵。如果 `Allocation[i, j] = k`，说明进程 Pi 目前分配了 k 个 Rj 类型的资源。  
4. Need：一个 n×m 的矩阵。如果 `Need[i, j] = k`，表示进程 Pi 可能还需要 k 个 Rj 类型的资源来完成任务。
`Need[i, j]` 的计算公式为：`Need[i, j] = Max[i, j] - Allocation[i, j]`。
向量 X 和 Y，长度都是 n。X≤Y 表示向量 X 中的每个元素都小于或等于向量 Y 中的对应元素。也就是说，对于所有的 i=1，2，...，n，都有 `X[i]≤Y[i]`。
矩阵 allocution 和 need 的每一行都可以看作是一个向量，分别被称为 $allocution_i$ 和 $need_i$。其中：
$Allocation_i$ 表示当前分配给进程 Pi 的资源。
$Need_i$ 表示进程 Pi 可能还需要完成的任务所需的额外资源。
### Safety Algorithm
Safety Algorithm 的主要步骤：
1. 初始化：设置 Work 向量为可用资源，Finish 向量为长度为 n 的 vector，初始状态下，所有进程的 Finish 变量都为 false。
2. 寻找一个索引 i，满足以下条件：
	a. Finish[i] 为 false
	b. Needi ≤ Work
	如果找不到这样的 i，则执行步骤 4。
3. 分配资源：将分配给进程 Pi 的资源添加到 Work 向量中，并将 Finish[i] 设置为 true。然后返回步骤 2。
4. 检查系统状态：如果所有进程的 Finish[i] 都为 true，则系统处于安全状态。

![image-20231031090922016](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20231031090922016.png)
### Resource-Request Algorithm
 【资源请求算法】（Resource-Request Algorithm）是一种在操作系统中处理资源分配和死锁问题的一种方法。该算法主要涉及到进程在请求资源时，如何判断和处理请求是否会影响系统的安全性。
在资源请求算法中，有以下几个关键点：
1. 每个进程都有一个请求向量（request vector），用于表示该进程所需的各种资源类型及其数量。
2. 当一个进程请求某个资源时，系统需要检查该请求是否符合以下条件：  
   a. 请求的资源数量不超过进程所需的最大资源数量。  
   b. 请求资源后，系统仍然处于安全状态。
3. 系统通过检查进程的请求向量和当前系统中的可用资源，来判断请求是否可以被满足。如果满足条件，系统将为进程分配资源；否则，进程需要等待其他进程释放足够的资源。
4. 进程在获得所需资源后，需要在有限时间内释放这些资源，以避免资源锁定现象。
资源请求算法的主要目的是确保系统在分配资源时始终保持安全状态，避免死锁的发生。通过进程提交资源请求，系统可以动态地检查资源分配状态，以便在满足进程需求的同时，确保系统资源的有效分配。这种算法有助于维护系统的稳定性和安全性，从而提高操作系统的性能。

Example of Banker’s Algorithm

![image-20231031091028134](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20231031091028134.png)

![image-20231031091100682](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20231031091100682.png)

## Deadlock Detection

### Single Instance of Each Resource Type

![image-20240105125855588](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20240105125855588.png)

死锁等价于wait-for graph有环

### Several Instances of a Resource Type

- 可用资源（Available）：一个长度为m的向量，用来表示每种类型资源的可用数量。在进程需要资源时，这个向量会动态变化，以反映当前系统内每种资源的剩余数量。
- 分配（Allocation）：一个n×m的矩阵，用来定义当前分配给每个进程的每种类型资源的数量。矩阵的每一行代表了对应进程所分配到的资源类型和数量。
- 请求（Request）：一个n×m的矩阵，表示每个进程当前的资源请求。如果`Request[i, j] = k`，那么进程Pi正在请求k个资源类型Rj的实例。这个矩阵帮助系统了解各个进程还需要哪些资源，以便进行相应的分配。

在分配和请求矩阵中，每一行都可以被视为一个向量，分别称为Allocation i和Request i，这样可以更方便地表示和引用每个进程的分配和请求情况。

### Detection Algorithm

#### Example of Detection Algorithm

![image-20240105130536139](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20240105130536139.png)

![image-20240105130606885](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20240105130606885.png)

![image-20240105131609792](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20240105131609792.png)

![image-20240105131631556](https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20240105131631556.png)

#### Detection-Algorithm Usage

何时以及多久调用一次死锁检测算法取决于以下几个因素：
- 死锁多久可能发生一次？
- 需要回滚多少个进程？

对于每个不相关的循环，都需要一个回滚。
死锁只有在某个进程提出了一个不能立即满足的请求时才会发生。
- 每当有资源分配的请求不能立即被满足时，就调用死锁检测算法。
- 这样做可能会在计算时间上产生相当大的开销。因此，可以定义一个时间间隔，比如每小时调用一次算法，或者当CPU利用率低于40%时调用。

如果随意调用检测算法，资源图（resource graph）中可能会有许多循环，这样我们就无法判断是哪个死锁进程“导致了”死锁。因此，需要合理地安排死锁检测的频率，以确保能够有效地识别和处理死锁，同时又不至于过度增加系统的开销。

## Recovery from Deadlock

当系统中存在死锁时：
- 告知操作员，手动处理死锁。或者让系统自动从死锁中恢复。

为了打破死锁：
- 终止一个或多个进程。
- 预占有一些资源，从死锁的进程中的一个或多个进程中。

在处理死锁时，需要考虑以下问题：
- 成本：终止进程或抢占资源可能会带来一定的成本，比如重新启动进程的开销，或者可能导致系统性能下降。
- 规则：需要有一套明确的规则来决定如何识别和打破死锁，比如银行家算法就是一种常用的避免死锁的算法。
- 公平：在抢占资源时，需要考虑公平性问题，确保不会对任何进程造成不公平的待遇。

为了预防死锁，可以制定以下规则：
- 资源分配规则：确保资源的分配不会导致循环等待条件的发生。
- 进程调度规则：合理安排进程的执行顺序，避免多个进程因为资源竞争而相互等待。
- 死锁检测和恢复机制：定期检测系统是否存在死锁，并在发现死锁时采取恢复措施，比如终止或抢占资源。

### Process Termination

为了通过终止进程来消除死锁：
- 终止所有死锁的进程。
- 逐个终止进程，直到死锁循环被消除。

系统会回收所有分配给已终止进程的资源。那么，我们应该按照什么顺序选择一个进程来终止呢？这里涉及到成本考虑：
- 进程的优先级。
- 进程已经计算了多长时间，以及还需要多长时间才能完成。
- 进程已经使用了多少资源，以及是什么类型的资源。
- 进程完成还需要多少更多的资源。
- 需要终止多少个进程。
- 进程是交互式的还是批处理的？

### Resource Preemption

连续从进程预占一些资源，并将这些资源分配给其他进程，直到打破死锁循环。选择一个牺牲品——哪些资源和哪些进程应该被预占？
- 最小化成本。
- 回滚——将进程恢复到某个安全状态，并从该状态重新启动。
  - 总体回滚：终止进程，然后重新启动它。
- 饥饿——同一个进程可能总是被选为牺牲品。
- 在成本因素中包括回滚的次数。

在选择牺牲品时，需要考虑以下因素来最小化成本：
1. 优先级：通常，优先级较低的进程更容易被选为牺牲品。
2. 资源使用情况：已经占用较多资源的进程可能更容易导致死锁，因此可能被选为牺牲品。
3. 进程的状态：如果进程处于一个可以安全回滚的状态，那么它可能被选为牺牲品。
4. 回滚的代价：如果一个进程需要频繁回滚，那么它的成本可能较高，因此可能被选为牺牲品。
为了避免饥饿现象，即同一个进程总是被选为牺牲品，可以采取一些策略，比如轮流选择牺牲品，或者在选择牺牲品时考虑进程的公平性。
在考虑成本时，需要将回滚的次数作为一个重要因素。如果一个进程经常因为死锁而需要回滚，那么它的总体成本可能会很高，因此在选择牺牲品时需要考虑这一情况。

### Combined Approach to Deadlock Handling

综合方法处理死锁：
- 预防（Prevention）
- 避免（Avoidance）
- 检测（Detection）

将三种基本方法结合起来，允许针对系统中每种资源使用最优方法。
- 将资源划分为层次结构化的类别。
- 在每个类别内使用最合适的死锁处理技术。


## 期末考计算题

1. 根据资源、进程间的请求关系，画出Resource-Allocation Graph
2. 根据资源分配图分析死锁出现的资源条件，或避免死锁的资源条件
3. Deadlock Avoidance
	1. 当每类资源只有一个资源实例，利用Resource-Allocation Graph Algorithm判断有无死锁/系统是否安全
	2. 当资源可有多个资源实例时，利用Banker Algorithm判断系统是否安全?(无死锁?), 进程的资源请求是否be granted
4. Deadlock Detecting
	1. 当每类资源只有一个资源实例，利用waiting graph判断有无死锁?
	2. 当资源可有多个资源实例时，利用deadlock detecting algorithm 判断有死锁?

