<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>计算机基础 on Bethel</title>
        <link>http://localhost:1313/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</link>
        <description>Recent content in 计算机基础 on Bethel</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 01 Nov 2023 14:57:20 +0000</lastBuildDate><atom:link href="http://localhost:1313/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>外部排序</title>
        <link>http://localhost:1313/post/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/</link>
        <pubDate>Wed, 01 Nov 2023 14:57:20 +0000</pubDate>
        
        <guid>http://localhost:1313/post/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/</guid>
        <description>&lt;h1 id=&#34;外部排序&#34;&gt;外部排序&lt;/h1&gt;
&lt;h1&gt;1.外部排序的基本概念&lt;/h1&gt; 
&lt;p&gt;外存中的数据读入内存→在内存中排序→数据写入外存&lt;/p&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;h1 id=&#34;2.%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F&#34;&gt;2.外部排序&lt;/h1&gt; 
&lt;h2 id=&#34;2.1.%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3&#34;&gt;2.1.外部排序的思想&lt;/h2&gt; 
&lt;p&gt;采用归并排序的思想和方法&lt;/p&gt; 
&lt;p&gt;1.数据初始状态&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/fb60815e51ad406fa96a80ad827847e6.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;2.将&amp;#xff08;36、8、26&amp;#xff09;&amp;#xff08;42、9、48&amp;#xff09;分别存入输入缓冲区1、输入缓冲区2&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/b9f282cd18524b46a1609e8a2bfe05c1.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;3.将输入缓冲区1和输入缓冲区2的数据进行递增排序&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/6fad1f6bdc5a4c8097aa3e2657f7fa62.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;4.将输入缓冲区1和输入缓冲区2的数据通过输出缓冲区逐一写入外存&amp;#xff0c;形成一个有序归并段&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/2ef4a5a1ff73456da37eda0e863b4258.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;5.将&amp;#xff08;1、37、25&amp;#xff09;&amp;#xff08;45、27、28&amp;#xff09;分别存入输入缓冲区1、输入缓冲区2&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/b4b6d4c0be484302ae4217a4c687d1a2.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;6.将输入缓冲区1和输入缓冲区2的数据进行递增排序&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/21090c7c92904c30afcf68f94295c4bb.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;7.将输入缓冲区1和输入缓冲区2的数据通过输出缓冲区逐一写入外存&amp;#xff0c;形成一个有序归并段&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/3e1d9b549f63450faa4f2f9a6a4cec29.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;8.对剩余12块内存依次进行上述操作&amp;#xff0c;总共需要进行16次读操作和16次写操作&amp;#xff0c;得到初始归并段&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/3ecc414b5b824b34a181bacc42d70ee5.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;9.第一次归并&amp;#xff1a;读入归并段1和归并段2中的第一块磁盘&amp;#xff08;相对最小&amp;#xff09;&amp;#xff0c;进行排序&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/b2f0bc600f5f4c6b84607887401587a3.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;10.依次找出这两个输入缓冲区中最元素&amp;#xff0c;并将其移动到输出缓冲区中&amp;#xff0c;当输出缓冲区满&amp;#xff0c;则写入外存&amp;#xff08;1、8、9&amp;#xff09;&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/99ee841270b54d7788264256a0f1b851.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;11.继续找出这剩余元素中的最小元素&amp;#xff0c;直到某一个缓冲区中空&amp;#xff0c;则读入其所属归并段的后一个内存块的数据&amp;#xff0c;并继续进行上述操作。直到两个缓冲区都空&amp;#xff0c;且归并段1和归并段2中的元素全部读入内存&amp;#xff0c;此时归并段1和归并段2就得到了一个有序的递增序列&lt;/p&gt; 
&lt;p&gt;输入缓冲区1空&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/f260376ffd784583a505675271b3a4ca.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;输入归并段1的第二块内存 &lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt; &lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/d44b8e35563d448198a17308af438d85.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;排序完成&amp;#xff0c;归并段1和归并段2递增有序 &lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/cfa296373aa44a3eb732caa184f96dbb.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;12.对剩余的六个归并段进行上述操作&amp;#xff0c;八个归并段→四个归并段&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/bf234ec9f4ca4f038e8b61fd84628756.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;13.第二次归并&amp;#xff1a;继续采用此方法依次取出归并段1和归并段2&amp;#xff08;归并段1为八个归并段时的归并段1和归并段2&amp;#xff0c;归并段2为八个归并段时的归并段3和归并段4&amp;#xff09;的各个块进行排序操作&amp;#xff08;步骤9、10、11&amp;#xff09;→四个归并段→两个归并段&lt;/p&gt; 
&lt;p&gt;原归并段1、2排序形成归并段1&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/5297c6b268af41dc9d741b059a03e76b.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;原归并段3、4排序形成归并段2&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/afc4e60dfd0e4192bb8cccd4789492f4.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;14.第三次归并&amp;#xff1a;继续排序归并段1、2&amp;#xff0c;形成最后的有序递增序列&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/01d3d620ae3c4d1b9a5e047919deae31.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h2 id=&#34;2.2.%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BC%80%E9%94%80&#34;&gt;2.2.外部排序的开销&lt;/h2&gt; 
&lt;p&gt;上述外部排序中&amp;#xff1a;形成初始归并段→第一次归并&amp;#xff08;8 ~ 4&amp;#xff09;→第二次归并&amp;#xff08;4 ~ 2&amp;#xff09;→第三次归并(2 ~ 1)&amp;#xff08;每个过程都需要读和写16次&amp;#xff0c;共32 &amp;#43; 32 * 3 &amp;#61; 128次&amp;#xff09;&lt;/p&gt; 
&lt;p&gt;总时间开销 &amp;#61; 内部排序所需时间 &amp;#43; 内部归并所需时间 &amp;#43; 外部读写所需时间&lt;/p&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;h2 id=&#34;2.3.%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6&#34;&gt;2.3.优化——多路归并&lt;/h2&gt; 
&lt;p&gt;改用四路归并&amp;#xff1a;初始化归并段→第一次归并&amp;#xff08;8 ~ 2&amp;#xff09;→第二次归并&amp;#xff08;2 ~ 1&amp;#xff09;&lt;/p&gt; 
&lt;p&gt;需要读写次数&amp;#xff1a;32 &amp;#43; 32 * 2 &amp;#61; 96&lt;/p&gt; 
&lt;p&gt;但是&amp;#xff0c;与此同时&amp;#xff0c;缓冲区的数量也要变成四个&amp;#xff08;k路归并需k个缓冲区&amp;#xff09;&lt;/p&gt; 
&lt;p&gt;结论&amp;#xff1a;1.对于 r 个初始归并段进行 k 路归并&amp;#xff0c;需要归并趟数 &amp;#61; &lt;img alt=&#34;log_k{r}&#34; class=&#34;mathcode&#34; src=&#34;https://latex.codecogs.com/gif.latex?log_k%7Br%7D&#34; /&gt;&amp;#xff08;向上取整&amp;#xff0c;归并树高度&amp;#xff09;&lt;br /&gt; 2.提升外部排序的速度、减少读写磁盘的速度的方法&amp;#xff1a;提高 k 值&amp;#xff0c;降低 r 值。&lt;/p&gt; 
&lt;p&gt;提高 r 值&amp;#xff1a;增加归并段长度&lt;/p&gt; 
&lt;p&gt;但是&amp;#xff0c;提高 k 有负面影响&amp;#xff1a;&lt;/p&gt; 
&lt;p&gt;A.需要的缓存空间升高&amp;#xff08;k路归并需k个缓冲区&amp;#xff09;&lt;/p&gt; 
&lt;p&gt;B.内部归并的所需时间提高&amp;#xff08;选出最小关键字需要进行k - 1次比较&amp;#xff09;&lt;/p&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;h1 id=&#34;3.%E8%B4%A5%E8%80%85%E6%A0%91&#34;&gt;3.败者树&lt;/h1&gt; 
&lt;p&gt;视为一棵完全二叉树&lt;/p&gt; 
&lt;p&gt;1.将每个归并段的第一个元素作为叶子结点加入败者树中&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/91cfd388e9764c438cd426395c868bc3.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;2.从左至右、从上往下的更新分支节点的信息&amp;#xff1a;判断其左右子树的大小&amp;#xff0c;除了根节点&amp;#xff08;最上面那个结点&amp;#xff09;记录冠军来自哪个归并段外&amp;#xff0c;其余各分支节点记录的是失败者来自哪个归并段&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/3b876d682c5b424e959671bafd66272b.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;3.取出最小的元素1后&amp;#xff0c;从其所属的归并段中取出下一个元素6&amp;#xff0c;依次与从叶子结点到根节点的各个结点所记录的败者信息进行对比&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/85d5cc24e6404d9ab01c906e2eafea6b.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt; 引进败者树后&amp;#xff0c;选出最小的关键字&amp;#xff0c;仅需log2k次比较&amp;#xff08;向上取整&amp;#xff09;&lt;/p&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;h1 id=&#34;4.%E7%BD%AE%E6%8D%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F&#34;&gt;4.置换选择排序&lt;/h1&gt; 
&lt;h2 id=&#34;4.1.%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3&#34;&gt;4.1.算法思想&lt;/h2&gt; 
&lt;p&gt;使用选择置换排序&amp;#xff0c;可以让每个初始段的长度不再受限于内存工作区大小&lt;/p&gt; 
&lt;p&gt;设内存工作区最多容纳w个数据&lt;/p&gt; 
&lt;p&gt;①将待排序文件FI输入w个数据到内存工作区WA中&lt;/p&gt; 
&lt;p&gt;②选择WA中关键字最小的数据&amp;#xff0c;输出到FO中&amp;#xff0c;并且用MIN记录该最小关键字&lt;/p&gt; 
&lt;p&gt;③若FI不空&amp;#xff0c;则从FI中继续输入文件到WA&lt;/p&gt; 
&lt;p&gt;④ 从WA中选出比MIN更大的关键字的数据&amp;#xff0c;输出并更新此最小关键字作为新MIN&lt;/p&gt; 
&lt;p&gt;⑤重复②~④直到WA中的每个关键字都&amp;#xff1e;MIN为止&amp;#xff0c;由此得到一个新的归并段&lt;/p&gt; 
&lt;p&gt;⑥重复②~⑤&amp;#xff0c;直到WA空&amp;#xff0c;得到全部初始归并段&lt;/p&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;h2 id=&#34;4.2.%E6%89%8B%E7%AE%97%E8%BF%87%E7%A8%8B&#34;&gt;4.2.手算过程&lt;/h2&gt; 
&lt;p&gt;1.初始状态&lt;/p&gt; 
&lt;p style=&#34;text-align:center;&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;https://img-blog.csdnimg.cn/42329fe0b10f4890b566888947c03402.png?x-oss-process&amp;#61;image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16&#34; /&gt;&lt;/p&gt; 
&lt;p&gt;归并段1&amp;#xff1a; &lt;/p&gt; 
&lt;p&gt;2.4、6、9依次加入内存工作区中&amp;#xff0c;&amp;#xff08;4、6、9&amp;#xff09;选择最小的元素4&amp;#xff0c;输出4并更改MIN &amp;#61; 4&lt;/p&gt; 
&lt;p&gt;3.加入7&amp;#xff0c;&amp;#xff08;7、6、9&amp;#xff09;选择最小元素6 &amp;gt; MIN &amp;#61; 4&amp;#xff0c;输出6并更改MIN &amp;#61; 6&lt;/p&gt; 
&lt;p&gt;4.加入13&amp;#xff0c;&amp;#xff08;7、13、9&amp;#xff09;选择最小元素7 &amp;gt; MIN &amp;#61; 6&amp;#xff0c;输出7并更改MIN &amp;#61; 7&lt;/p&gt; 
&lt;p&gt;5.加入11&amp;#xff0c;&amp;#xff08;11、13、9&amp;#xff09;选择最小元素9 &amp;gt; MIN &amp;#61; 7&amp;#xff0c;输出9并更改MIN &amp;#61; 9&lt;/p&gt; 
&lt;p&gt;6.加入16&amp;#xff0c;&amp;#xff08;11、13、16&amp;#xff09;选择最小元素11 &amp;gt; MIN &amp;#61; 9&amp;#xff0c;输出11并更改MIN &amp;#61; 11&lt;/p&gt; 
&lt;p&gt;8.加入14&amp;#xff0c;&amp;#xff08;14、13、16&amp;#xff09;选择最小元素13 &amp;gt; MIN &amp;#61; 11&amp;#xff0c;输出13并更改MIN &amp;#61; 13&lt;/p&gt; 
&lt;p&gt;9.加入10&amp;#xff0c;&amp;#xff08;14、&lt;span style=&#34;color:#494949;&#34;&gt;10&lt;/span&gt;、16&amp;#xff09;选择最小元素10 &amp;lt; MIN &amp;#61; 13&amp;#xff0c;标记13为不可输出&amp;#xff0c;选择第二小的元素14 &amp;gt; MIN &amp;#61; 13&amp;#xff0c;输出14并更改MIN &amp;#61; 14&lt;/p&gt; 
&lt;p&gt;10.加入22&amp;#xff0c;&amp;#xff08;22、&lt;span style=&#34;color:#fe2c24;&#34;&gt;10&lt;/span&gt;、16&amp;#xff09;选择最小元素16  &amp;gt; MIN &amp;#61; 14&amp;#xff0c;输出16并更改MIN &amp;#61; 16&lt;/p&gt; 
&lt;p&gt;11.加入30&amp;#xff0c;&amp;#xff08;22、&lt;span style=&#34;color:#fe2c24;&#34;&gt;10&lt;/span&gt;、30&amp;#xff09;选择最小元素22 &amp;gt; MIN &amp;#61; 16&amp;#xff0c;输出并更改MIN &amp;#61; 22&lt;/p&gt; 
&lt;p&gt;12.加入2&amp;#xff0c;&amp;#xff08;&lt;span style=&#34;color:#fe2c24;&#34;&gt;2&lt;/span&gt;、&lt;span style=&#34;color:#fe2c24;&#34;&gt;10&lt;/span&gt;、30&amp;#xff09;选择最小元素2 &amp;lt; MIN &amp;#61; 22&amp;#xff0c;标记2为不可输出&amp;#xff0c;选择第三小的元素30 &amp;gt; MIN &amp;#61; 22&amp;#xff0c;输出30并更改MIN &amp;#61; 30&lt;/p&gt; 
&lt;p&gt;13.加入3&amp;#xff0c;&amp;#xff08;&lt;span style=&#34;color:#fe2c24;&#34;&gt;2、10、3&lt;/span&gt;&amp;#xff09;选择最小元素3 &amp;lt; MIN &amp;#61; 30&amp;#xff0c;标记2为不可输出&amp;#xff0c;此时&amp;#xff0c;输出缓冲区中的三个元素都是不可输出元素&amp;#xff0c;则&lt;span style=&#34;color:#fe2c24;&#34;&gt;第一个归并区到上一个输出元素为止&amp;#xff08;4、6、7、9、11、13、14、16、22、30&amp;#xff09;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;归并段2&amp;#xff1a; &lt;/p&gt; 
&lt;p&gt;14.&amp;#xff08;2、10、3&amp;#xff09;选择最小元素2&amp;#xff0c;输出2并更改MIN &amp;#61; 2&lt;/p&gt; 
&lt;p&gt;15.加入19&amp;#xff0c;&amp;#xff08;19、10、3&amp;#xff09;选择最小元素3 &amp;gt; MIN &amp;#61; 2&amp;#xff0c;输出3并更改MIN &amp;#61; 3&lt;/p&gt; 
&lt;p&gt;16.加入20&amp;#xff0c;&amp;#xff08;19、10、20&amp;#xff09;选择最小元素10 &amp;gt; MIN &amp;#61; 3&amp;#xff0c;输出10并更改MIN &amp;#61; 10&lt;/p&gt; 
&lt;p&gt;17.加入17&amp;#xff0c;&amp;#xff08;19、17、20&amp;#xff09;选择最小元素17 &amp;gt; MIN &amp;#61; 10&amp;#xff0c;输出17并更改MIN &amp;#61; 17&lt;/p&gt; 
&lt;p&gt;18.加入1&amp;#xff0c;&amp;#xff08;19、&lt;span style=&#34;color:#fe2c24;&#34;&gt;1&lt;/span&gt;、20&amp;#xff09;选择最小元素1 &amp;lt; MIN &amp;#61; 17&amp;#xff0c;标记1为不可输出&amp;#xff0c;选择第二小的元素19 &amp;gt; MIN &amp;#61; 17&amp;#xff0c;输出19并更改MIN &amp;#61; 19&lt;/p&gt; 
&lt;p&gt;19.加入23&amp;#xff0c;&amp;#xff08;23、&lt;span style=&#34;color:#fe2c24;&#34;&gt;1&lt;/span&gt;、20&amp;#xff09;选择最小元素20 &amp;gt; MIN &amp;#61; 19&amp;#xff0c;输出20并更改MIN &amp;#61; 20&lt;/p&gt; 
&lt;p&gt;20.加入5&amp;#xff0c;&amp;#xff08;23、&lt;span style=&#34;color:#fe2c24;&#34;&gt;1、5&lt;/span&gt;&amp;#xff09;选择最小元素5 &amp;lt; MIN &amp;#61; 20&amp;#xff0c;标记5为不可输出&amp;#xff0c;选择第三小的元素23 &amp;gt; MIN &amp;#61; 23&amp;#xff0c;输出23并更改MIN &amp;#61; 23&lt;/p&gt; 
&lt;p&gt;21.加入36&amp;#xff0c;&amp;#xff08;36、&lt;span style=&#34;color:#fe2c24;&#34;&gt;1、5&lt;/span&gt;&amp;#xff09;选择最小元素36 &amp;gt; MIN &amp;#61; 36&amp;#xff0c;输出36并更改MIN &amp;#61; 36&lt;/p&gt; 
&lt;p&gt;22.加入22&amp;#xff0c;&amp;#xff08;&lt;span style=&#34;color:#fe2c24;&#34;&gt;12、1、5&lt;/span&gt;&amp;#xff09;选择最小元素12 &amp;lt; MIN &amp;#61; 36&amp;#xff0c;标记12为不可输出时&amp;#xff0c;输出缓冲区中的三个元素都是不可输出元素&amp;#xff0c;则&lt;span style=&#34;color:#fe2c24;&#34;&gt;第二个归并区到上一个输出元素为止&amp;#xff08;2、3、10、17、19、20、23、36&amp;#xff09;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;第三个归并段&amp;#xff1a;&lt;/p&gt; 
&lt;p&gt;23.&amp;#xff08;12、1、5&amp;#xff09;选择最小元素1&amp;#xff0c;输出1并更改MIN &amp;#61; 1&lt;/p&gt; 
&lt;p&gt;24.加入18&amp;#xff0c;&amp;#xff08;12、18、5&amp;#xff09;选择最小元素5 &amp;gt; MIN &amp;#61; 1&amp;#xff0c;输出5并更改MIN &amp;#61; 5&lt;/p&gt; 
&lt;p&gt;25.加入21&amp;#xff0c;&amp;#xff08;12、18、21&amp;#xff09;选择最小元素12 &amp;gt; MIN &amp;#61; 5&amp;#xff0c;输出12并更改MIN &amp;#61; 12&lt;/p&gt; 
&lt;p&gt;26.加入39&amp;#xff0c;此时&amp;#xff0c;待排序文件空&amp;#xff0c;将内存工作区中的剩余数据按序输出&amp;#xff0c;即18、21、39&amp;#xff0c;则第三个归并段为&amp;#xff08;1、5、12、18、21、39&amp;#xff09;&lt;/p&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;h1 id=&#34;5.%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91&#34;&gt;5.最佳归并树&lt;/h1&gt; 
&lt;p&gt;1.性质和构造完全相同于哈弗曼树&lt;/p&gt; 
&lt;p&gt;2.与哈弗曼树的区别&amp;#xff1a;&lt;/p&gt; 
&lt;p&gt;k叉树&amp;#xff0c;其中k &amp;gt; 2时&amp;#xff1a;需要判断是否能满足构造完全k叉树&amp;#xff0c;若不满足&amp;#xff0c;则需要添加长度为0的“虚段”&lt;/p&gt; 
&lt;p&gt;①若&amp;#xff08;初始归并段数量 - 1&amp;#xff09; % &amp;#xff08;k - 1&amp;#xff09; &amp;#61; 0&amp;#xff0c;则能构成完全k叉树&lt;/p&gt; 
&lt;p&gt;②若&amp;#xff08;初始归并段数量 - 1&amp;#xff09; % &amp;#xff08;k - 1&amp;#xff09;&amp;#61; u ≠ 0&amp;#xff0c;则说明需要添加&amp;#xff08;k - 1&amp;#xff09;- u 个虚段才能构成完全二叉树&lt;/p&gt; 
&lt;hr&gt;
&lt;p&gt;1.外部排序基本概念：前面介绍的排序都是内部排序，是直接在内存里面进行排序的，但是大多数情况下文件比较大，这时候我们就得把文件分割成一个个小块进行输入内存再排序。在排序过程中需要进行多次的内存与外存之间的交互，所以称之为外部排序。&lt;/p&gt;
&lt;p&gt;外部排序操作：以例题作为讲解&lt;/p&gt;
&lt;p&gt;例题1：假设文件有4500个记录，每块磁盘可以放75个记录，计算机中用于排序的内存区可以存放 450 个记录，试问：
1）可以建立多少个初始归并段？每个归并段有多少个记录？存放于多少个块中？
2）应采用几路归并，请写出每趟需要读写磁盘的块数&lt;/p&gt;
&lt;p&gt;解答：
1） 文件中有4500个记录，内部排序区可容纳450个记录（其实排序过程是 依次 输入1-450，451-900… 进行排序，然后输出构成有序的初始归并段 ），则可建立的初始归并段为4500/450 = 10，每个初始归并段有450个记录，存放于 450/75 =6 个块中。
2）内存区可以容纳6个块，所以可以建立5个输入缓冲区。1个输出缓冲区，因此采用5路归并。
归并次数为 log(5)10 = 2，每次归并需要读写磁盘次数都为4500/75=60 次 ，每次归并需要读写磁盘总次数为为60 * 2 =120 次，做了两趟归并，读写总次数 2 * 120=240。
另外再来看看
2.外部排序总时间= 内部排序所需时间+外村信息读写时间+内部归并需要时间&lt;/p&gt;
&lt;p&gt;内部排序所需时间 ：就是第一次进行生成初始归并序列的时间，这其中就有一次读写时间，排序时间可以忽略。如上题内部排序所需时间为 120 相当于一次归并的时间
外存信息读写时间 ：其实就是归并次数乘以每次读写时间，上题为 两次归并，每次归并读写磁盘次数为120 ，所以总时间为2 * 120 = 240次。
内部归并需要时间：就是在内存中进行序列段合并为一个序列段所需时间，这一时间其实主要在于数据进行比较的时间，例如上题，进行的是5路归并，那么在5个元素中选取最小数比较次数是4次，总共有4500个记录，最后一个不需要比较，因此每趟归并需要的比较次数为 （4500-1）*4=17996次，进行两次归并，17996 *2=35992次比较。但是比较时间相比于读写时间比较短所以可以忽略。&lt;/p&gt;
&lt;p&gt;归并次数 S=log(k) r 。r为初始归并段，k为归并路数，证明很简单，略。若是不采用其他方法进行比较次数优化则S趟总共需要比较次数为 S( n-1 )( k-1) = [ log(k) r ] ( n-1 )( k-1)=[log2 r] (n-1)(k-1)/[log2k] ,式子中 (k-1)/log2k 随着路数k的增大而增大，这将抵消由于k增大而减少外存访问次数所得到的效益，那么能不能使用其他方法来减少比较次数呢？下面介绍败者树方法。
败者树：树中k个叶节点分别存放k个归并段在归并过程中当前参加比较的记录，内部节点用来记录左右子树的 “败者” 而胜利者继续向上比较直到到达根节点，如图所示。
在这里插入图片描述&lt;/p&gt;
&lt;p&gt;因为 k 路归并的败者树深度为log2k ， 因此k 个记录中选择最小关键字，最多需要 log2k次比较，所以排序总的比较次数为S(n-1)[log2k]=[log(k)r] (n-1) log2k=(n-1) log2r 。 可见使用败者树后内部归并的比较次数就与k无关了，因此只要内存空间允许，可以通过增大路数k达到减少 I/O 次数，提高外部排序速度。
值得说明的是，归并路数k并不是越大越好，归并路数k增大，相应的得增加输入缓冲区的块数，若是可使用的空间一定，势必要减少每个输入缓冲区的容量，这样也会使得内存、外存交换数据次数增加，因此仍然会导致时间增大。&lt;/p&gt;
&lt;p&gt;还有什么办法可以减少排序时间呢？&lt;/p&gt;
&lt;p&gt;3.置换选择排序（生成初始归并段）
只要增大初始归并段长度就可以减少初始归并段个数，达到减少归并时间的效果。&lt;/p&gt;
&lt;p&gt;在这里插入图片描述
上述算法中WA选择最小数使用败者树实现。&lt;/p&gt;
&lt;p&gt;综上所述：每一次归并所读取 I/O 的次数是一定的，总记录/每块磁盘容量，因此可以通过减少归并次数，达到减少读取次数减少排序时间问题，那么减少归并次数的方法有：增大归并路数 或者 增大初始序列 。
实现代码：&lt;/p&gt;
&lt;p&gt;void Select_MiniMax(LoserTree ls,WorkArea wa,int q){
int p, s, t;
// ls[t]为q的双亲节点，p作为中介&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(t = (w+q)/2,p = ls[t]; t &amp;gt; 0;t = t/2,p = ls[t]){
    // 段号小者 或者 段号相等且关键字更小的为胜者
    if(wa[p].rnum &amp;lt; wa[q].rnum || (wa[p].rnum == wa[q].rnum &amp;amp;&amp;amp; wa[p].key &amp;lt; wa[q].key)){
        s=q;
        q=ls[t]; //q指示新的胜利者
        ls[t]=s;
    }
}
ls[0] = q; // 最后的冠军
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
//输入w个记录到内存工作区wa,建得败者树ls,选出关键字最小的记录，并由s指示其在wa中的位置。
void Construct_Loser(LoserTree ls, WorkArea wa, FILE *fi){
int i;
for(i = 0; i &amp;lt; w; ++i){
wa[i].rnum = wa[i].key = ls[i] = 0;
}
for(i = w - 1; i &amp;gt;= 0; &amp;ndash;i){
fread(&amp;amp;wa[i].rec, sizeof(RedType), 1, fi);// 输入一个记录
wa[i].key = wa[i].rec.key; // 提取关键字
wa[i].rnum = 1; // 其段号为＂1＂
Select_MiniMax(ls,wa,i); // 调整败者树
}
}&lt;/p&gt;
&lt;p&gt;4.最佳归并树&lt;/p&gt;
&lt;p&gt;文件经过置换选择排序后，得到的是长度不等的初始归并段，下面讨论如何组织长度不等的初始归并段的归并顺序使得IO次数最少。其实也就是m叉哈夫曼树类似，很简单，不展开叙述。其中有一点不同是，可能初始归并段个数并不能构成严格的k叉树，这时就要补充虚段了。&lt;/p&gt;
&lt;p&gt;如何确定添加虚段的数目？
设度为0的节点有 N0 个，度为 k的节点个数有Nk个，则对于严格k叉树 N0=(k-1) Nk+1，由此可得Nk=(N0-1)/(k-1) 。&lt;/p&gt;
&lt;p&gt;若是(N0-1)%(k-1) =0 , 则说明这N0个叶节点正好可以构成严格k叉树。
若是不等于0，则设需要添加 m个 长度为0 的虚段使得（N0+m-1）%（k-1）=0，即可。
以上就是外部排序的全部内容&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
