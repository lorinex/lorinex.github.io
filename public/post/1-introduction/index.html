<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='1 Introduction Computer System Components 可以计算机系统分成三个基本组成部分：底层的计算机硬件、中间层的操作系统以及上层的计算机应用程序，操作系统属于承上启下的中间层，所以'>
<title>1 Introduction | Bethel's Blog</title>

<link rel='canonical' href='https://www.xxx.blog/post/1-introduction/'>

<link rel="stylesheet" href="/scss/style.min.c3c7ecff622b4ad3ac6aacf17244c017cc674f0e82b470bfb8f4de85243313d0.css"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"K3aYNEt3ZeYoZwhE",ck:"K3aYNEt3ZeYoZwhE"})</script>
<script async src="https://umami.xalaok.top/uanalytics" data-website-id="095ee454-e560-4d9b-bf1c-869f8529c17f"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//instant.page/5.2.0" type="module" integrity="sha384-jnZyxPjiipYXnSU0ygqeac2q7CVYMbh84q0uHVRRxEtvFPiQYbXWUorga2aqZJ0z"></script><meta property='og:title' content='1 Introduction'>
<meta property='og:description' content='1 Introduction Computer System Components 可以计算机系统分成三个基本组成部分：底层的计算机硬件、中间层的操作系统以及上层的计算机应用程序，操作系统属于承上启下的中间层，所以'>
<meta property='og:url' content='https://www.xxx.blog/post/1-introduction/'>
<meta property='og:site_name' content='Bethel'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2023-09-12T09:26:35&#43;00:00'/><meta property='article:modified_time' content='2023-09-12T09:26:35&#43;00:00'/>
<meta name="twitter:title" content="1 Introduction">
<meta name="twitter:description" content="1 Introduction Computer System Components 可以计算机系统分成三个基本组成部分：底层的计算机硬件、中间层的操作系统以及上层的计算机应用程序，操作系统属于承上启下的中间层，所以">
    <link rel="shortcut icon" href="/favicon.png" />
<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/lxgwwenkaigbscreen.css" />
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/tx_hu92c04046da3d4074953cad185e3935e5_62559_300x0_resize_q75_box.jpg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Bethel</a></h1>
            <h2 class="site-description">Live and learn. ✍️</h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>首页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-sun-high" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M14.828 14.828a4 4 0 1 0 -5.656 -5.656a4 4 0 0 0 5.656 5.656z" />
  <path d="M6.343 17.657l-1.414 1.414" />
  <path d="M6.343 6.343l-1.414 -1.414" />
  <path d="M17.657 6.343l1.414 -1.414" />
  <path d="M17.657 17.657l1.414 1.414" />
  <path d="M4 12h-2" />
  <path d="M12 4v-2" />
  <path d="M20 12h2" />
  <path d="M12 20v2" />
</svg>
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-moon-stars" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
  <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" />
  <path d="M19 11h2m-1 -1v2" />
</svg>
                    <span>深色模式</span>
                </li>
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#what-operating-systems-do">What Operating Systems do?</a>
      <ol>
        <li><a href="#user-view">User view</a></li>
        <li><a href="#system-view">System view</a></li>
        <li><a href="#defining-operating-systems">Defining Operating Systems</a></li>
      </ol>
    </li>
    <li><a href="#operating-system-feature">Operating System Feature</a>
      <ol>
        <li><a href="#concurrence">Concurrence</a></li>
        <li><a href="#sharing">Sharing</a></li>
        <li><a href="#virtual">Virtual</a></li>
        <li><a href="#asynchronism">Asynchronism</a></li>
      </ol>
    </li>
    <li><a href="#operating-system-function">Operating-System Function</a>
      <ol>
        <li><a href="#device-management">Device Management</a></li>
        <li><a href="#process-management">Process Management</a></li>
        <li><a href="#memory-management">Memory Management</a></li>
        <li><a href="#storage-management">Storage Management</a>
          <ol>
            <li><a href="#file-system-management">File-System Management</a></li>
            <li><a href="#mass-storage-management">Mass-Storage Management</a></li>
            <li><a href="#caching">Caching</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#operating-system-structure">Operating-System Structure</a>
      <ol>
        <li><a href="#uniprogramming">Uniprogramming</a></li>
        <li><a href="#multiprogramming">Multiprogramming</a></li>
        <li><a href="#time-sharing-systems">Time sharing systems</a></li>
        <li><a href="#real-time-operating-system">Real-time operating system</a></li>
      </ol>
    </li>
    <li><a href="#operating-system-operations">Operating-System Operations</a>
      <ol>
        <li><a href="#dual-mode-operation">Dual-mode operation</a>
          <ol>
            <li><a href="#user-mode-and-kernel-mode">user mode and kernel mode</a></li>
            <li><a href="#implementation-of-dual-mode-operation">Implementation of Dual-mode operation</a></li>
          </ol>
        </li>
        <li><a href="#interruption">Interruption</a>
          <ol>
            <li><a href="#defining-interruption">Defining Interruption</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#computer-system-organization">Computer-System Organization</a>
      <ol>
        <li><a href="#computer-system-operation">Computer-System Operation</a>
          <ol>
            <li><a href="#interrupt-timeline">Interrupt Timeline</a></li>
          </ol>
        </li>
        <li><a href="#storage-structure">Storage Structure</a>
          <ol>
            <li><a href="#storage-hierarchy">Storage Hierarchy</a></li>
            <li><a href="#storage-device-hierarchy">Storage-Device Hierarchy</a></li>
          </ol>
        </li>
        <li><a href="#io-structure">I/O Structure</a>
          <ol>
            <li><a href="#io-operation">I/O operation</a></li>
            <li><a href="#modern-computer-system">Modern Computer System</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#protection-and-security">Protection and Security</a></li>
  </ol>

  <ol>
    <li><a href="#operating-system-services">Operating System Services</a></li>
    <li><a href="#user-operating-system-interface">User Operating System Interface</a>
      <ol>
        <li><a href="#command-interpreter-cli">Command Interpreter (CLI)</a></li>
        <li><a href="#graphical-user-interface-gui">Graphical User Interface (GUI)</a></li>
      </ol>
    </li>
    <li><a href="#system-calls">System Calls</a>
      <ol>
        <li><a href="#system-call-implementation">System Call Implementation</a></li>
        <li><a href="#system-call-parameter-passing">System Call Parameter Passing</a></li>
      </ol>
    </li>
    <li><a href="#types-of-system-calls">Types of System Calls</a>
      <ol>
        <li><a href="#process-control">Process control</a>
          <ol>
            <li><a href="#fork">fork</a></li>
            <li><a href="#exec">exec</a></li>
            <li><a href="#exit">exit</a></li>
            <li><a href="#wait">wait</a></li>
          </ol>
        </li>
        <li><a href="#file-management">File management</a></li>
        <li><a href="#device-management-1">Device management</a></li>
        <li><a href="#communications">Communications</a></li>
        <li><a href="#information-maintenance">Information maintenance</a></li>
        <li><a href="#系统调用概述">系统调用概述</a></li>
        <li><a href="#protection">Protection</a></li>
      </ol>
    </li>
    <li><a href="#system-programs">System Programs</a></li>
    <li><a href="#operating-system-design-and-implementation">Operating System Design and Implementation</a></li>
    <li><a href="#operating-system-structure-1">Operating System Structure</a>
      <ol>
        <li><a href="#简单结构-simple-structure">简单结构 Simple structure</a>
          <ol>
            <li><a href="#ms-dos">MS-DOS</a></li>
            <li><a href="#original-unix">Original UNIX</a></li>
          </ol>
        </li>
        <li><a href="#分层结构-layered-approach">分层结构 Layered Approach</a></li>
        <li><a href="#微内核结构-microkernels">微内核结构 Microkernels</a></li>
        <li><a href="#模块化结构-modules">模块化结构 Modules</a></li>
      </ol>
    </li>
    <li><a href="#virtual-machines">Virtual Machines</a></li>
    <li><a href="#operating-system-generation">Operating System Generation</a></li>
    <li><a href="#操作系统生成">操作系统生成</a></li>
    <li><a href="#system-boot">System Boot</a>
      <ol>
        <li><a href="#操作系统引导过程">操作系统引导过程</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/os/" style="background-color: #2a9d8f; color: #fff;">
                操作系统
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/post/1-introduction/">1 Introduction</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2023-09-12</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 44 分钟
                </time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-pencil" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
  <path d="M13.5 6.5l4 4" />
</svg>
                <time class="article-words">
                    字数: 21901 字
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="1-introduction">1 Introduction<a hidden class="anchor" aria-hidden="true" href="#1-introduction">#</a></h1>
<p>Computer System Components</p>
<p>可以计算机系统分成三个基本组成部分：<strong>底层的计算机硬件、中间层的操作系统以及上层的计算机应用程序</strong>，操作系统属于承上启下的中间层，所以它在计算机系统中的地位和作用尤为重要。</p>
<blockquote>
<p>操作系统是计算机系统中最基本的系统软件；</p>
</blockquote>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/%E6%88%AA%E5%9B%BE_20230912091429.png"
	
	
	
	loading="lazy"
	
		alt="截图_20230912091429.png"
	
	
></p>
<h2 id="what-operating-systems-do">What Operating Systems do?<a hidden class="anchor" aria-hidden="true" href="#what-operating-systems-do">#</a></h2>
<h3 id="user-view">User view<a hidden class="anchor" aria-hidden="true" href="#user-view">#</a></h3>
<h3 id="system-view">System view<a hidden class="anchor" aria-hidden="true" href="#system-view">#</a></h3>
<ul>
<li>resource allocator</li>
<li>control program</li>
</ul>
<h3 id="defining-operating-systems">Defining Operating Systems<a hidden class="anchor" aria-hidden="true" href="#defining-operating-systems">#</a></h3>
<p>Kernel（nucleus）内核</p>
<ul>
<li>OS is the one program <strong>running at all times</strong> on the computer.(all else being system programs and application programs)</li>
<li>Portion of operating system that is in main memory. 常驻内存</li>
<li>Contains most-frequently used functions.频繁使用</li>
</ul>
<p>操作系统是计算机系统中的一个<strong>系统软件</strong>，是一些<strong>程序模块的集合</strong>，它们能以尽量有效、合理的方式<strong>组织和管理计算机的软硬件资源</strong>，合理地<strong>组织计算机的工作流程</strong>，<strong>控制程序的执行</strong>，向用户<strong>提供各种服务功能</strong></p>
<ol>
<li>操作系统是安装在计算机硬件之上的一层软件；操作系统之上可以安装各种应用程序软件；</li>
<li>用户可以通过应用程序软件来<u>间接</u>使用操作系统，也可以<u>直接</u>使用操作系统，但通常都是通过操作系统来最终使用计算机硬件的；
<ul>
<li>直接使用操作系统：让<u>用户</u>通过编写程序来<u>调用</u>操作系统提供的<u>系统接口</u>从而进入操作系统。</li>
<li>用户通过系统接口进入操作系统后使用计算机硬件，即用户必须“穿过”操作系统才能使用计算机硬件；</li>
</ul>
</li>
<li>操作系统管理计算机硬件，目的是让用户对计算机硬件的使用更加简便，也更加高效；</li>
</ol>
<h2 id="operating-system-feature">Operating System Feature<a hidden class="anchor" aria-hidden="true" href="#operating-system-feature">#</a></h2>
<p>操作系统是一种系统软件，操作系统的基本特征包括<strong>并发、共享、虚拟和异步</strong></p>
<h3 id="concurrence">Concurrence<a hidden class="anchor" aria-hidden="true" href="#concurrence">#</a></h3>
<p>并发是指两个或多个事件在<strong>同一时间间隔</strong>内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。</p>
<p>引入<strong>进程</strong>的目的是使程序能并发执行。</p>
<blockquote>
<p>Q：并发和并行的区别？
A：
并发：同一时间间隔
并行：同一时刻
基于单处理机的背景，实际上每个时刻仅能有一道程序执行，在一段时间内，宏观上有多道程序在同时执行，微观上这些程序仍然是分时交替执行的 —— 操作系统的并发性是通过分时得以实现的；</p>
</blockquote>
<p>而并行性需要有相关硬件的支持，要么是多流水线，要么是多处理机硬件；</p>
<h3 id="sharing">Sharing<a hidden class="anchor" aria-hidden="true" href="#sharing">#</a></h3>
<p>共享也就是资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用，共享可分为以下两种资源共享方式：
<strong>互斥共享方式</strong>：规定在一段时间内只允许一个进程访问资源，将在一段时间内只允许一个进程访问的资源成为临界资源或独占资源；
<strong>同时访问方式</strong>：“同时”通常是指宏观上的，微观上这些进程可能是交替地对资源进行访问，即“分时共享”；</p>
<h3 id="virtual">Virtual<a hidden class="anchor" aria-hidden="true" href="#virtual">#</a></h3>
<p>虚拟是指将一个物理上的实体变为若干逻辑上的对应物；
操作系统利用了多种虚拟技术来实现虚拟处理器、虚拟内存和虚拟外部设备等：
利用多道程序设计技术把一个物理上的CPU虚拟为多个逻辑上的CPU（即分时使用一个处理器），称为虚拟处理器；
将用户感受到的存储器称为虚拟存储器（实际存储器我们编程的时候根本接触不到）；
简单来说，操作系统的虚拟技术可以归纳为：时分复用技术（处理器的分时共享）和空分复用技术（虚拟存储器）</p>
<h3 id="asynchronism">Asynchronism<a hidden class="anchor" aria-hidden="true" href="#asynchronism">#</a></h3>
<p>异步是指由于资源有限，进程的执行不是一贯到底的，而是以不可预知的速度向前推进。</p>
<p>异步是在多道程序环境下允许多个程序并发执行极有可能导致的进程与时间有关的错误。</p>
<h2 id="operating-system-function">Operating-System Function<a hidden class="anchor" aria-hidden="true" href="#operating-system-function">#</a></h2>
<p>fundamental management modules：进程管理、存储器管理、设备管理以及文件系统</p>
<h3 id="device-management">Device Management<a hidden class="anchor" aria-hidden="true" href="#device-management">#</a></h3>
<p>The device management module is responsible for managing all the hardware devices of the computer. This includes monitoring the status of hardware devices, installing and configuring device drivers, and handling input/output operations.</p>
<p>Device Management in an operating system primarily encompasses the following functions:</p>
<ol>
<li><strong>Buffer Management</strong>: Buffer management is crucial for handling input/output operations efficiently. It involves temporarily storing data in a buffer while it is being transferred between two places, such as between a device and the main memory. This process helps in managing the speed differences between the devices and the CPU.</li>
<li><strong>Device Allocation</strong>: Device allocation refers to the allocation of various hardware resources to different processes or users. The operating system must manage the allocation of devices in a way that optimizes their usage while avoiding conflicts and ensuring fair access for all processes.</li>
<li><strong>Device Handling</strong>: Device handling involves managing the actual operation of the hardware devices. This includes interpreting commands, initiating operations, and monitoring the status of devices. The operating system communicates with device drivers, which are specific to each hardware device, to perform these operations.</li>
<li><strong>Virtual Devices</strong>: The concept of virtual devices involves abstracting the physical hardware into a more manageable form. This allows the operating system to provide more flexible and efficient device management by presenting hardware resources as virtual devices, which can be easier to manage and share among multiple processes.</li>
</ol>
<h3 id="process-management">Process Management<a hidden class="anchor" aria-hidden="true" href="#process-management">#</a></h3>
<ol>
<li><u>A process is a program in execution</u></li>
<li>进程在执行过程中需要分配<u>资源</u>，当进程完成任务或终止时，需要回收其占用的资源，以便其他进程可以使用。</li>
<li>单线程进程有一个<u>程序计数器（PC, Program Counter）</u>，用于指定下一条要执行的指令位置；多线程进程具有多个线程，每个线程都有一个独立的PC。</li>
<li>计算机系统可以在<u>一个或多个 CPU 上并发</u>运行多个进程，以提高系统性能。</li>
</ol>
<p>操作系统在与进程管理相关的活动中负责以下任务：</p>
<ul>
<li>创建和删除用户和系统进程</li>
<li>挂起和恢复进程</li>
<li>提供进程同步的机制</li>
<li>提供进程通信的机制</li>
<li>提供死锁处理的机制</li>
</ul>
<h3 id="memory-management">Memory Management<a hidden class="anchor" aria-hidden="true" href="#memory-management">#</a></h3>
<ol>
<li>CPU 能够直接寻址和访问的<strong>唯一大型存储设备</strong>是内存。</li>
<li>内存管理负责管理内存中存储的内容，从而提高 CPU 利用率和计算机响应用户的速度。</li>
<li>内存管理活动包括以下几个方面：
<ul>
<li>跟踪当前正在使用内存的部分以及使用者。</li>
<li>决定将哪些进程和数据移入和移出内存。</li>
<li>根据需要分配和释放内存空间。</li>
</ul>
</li>
</ol>
<h3 id="storage-management">Storage Management<a hidden class="anchor" aria-hidden="true" href="#storage-management">#</a></h3>
<ol>
<li>操作系统为信息存储提供了uniform, logical view，使得用户和程序能够以更加简洁的方式处理存储设备。</li>
<li>操作系统将物理存储介质抽象为逻辑存储单元，即文件。这种抽象使得用户可以忽略底层物理存储细节，更容易地管理和操作数据。</li>
<li>每种存储介质都由特定的设备控制，如磁盘驱动器、磁带驱动器等。这些设备具有不同的属性，如访问速度、容量、数据传输速率以及访问方法（顺序或随机）。</li>
</ol>
<h4 id="file-system-management">File-System Management<a hidden class="anchor" aria-hidden="true" href="#file-system-management">#</a></h4>
<p>文件通常组织成目录。 大多数系统具有<strong>访问控制</strong>来确定谁可以访问什么。</p>
<p>操作系统的活动包括：</p>
<ul>
<li>创建和删除文件</li>
<li>创建和删除目录以组织文件</li>
<li>支持用于操作文件和目录的基本操作</li>
<li>将文件映射到辅助存储设备</li>
<li>备份文件到稳定的（非易失性）存储介质。</li>
</ul>
<h4 id="mass-storage-management">Mass-Storage Management<a hidden class="anchor" aria-hidden="true" href="#mass-storage-management">#</a></h4>
<p>通常，磁盘用于存储无法容纳在主内存中的数据，或者需要在较长时间内保留的数据。</p>
<p>操作系统在磁盘管理方面的活动包括：</p>
<ul>
<li>空闲空间管理</li>
<li>存储分配</li>
<li>磁盘调度</li>
</ul>
<p>计算机操作的整体速度高度依赖于磁盘子系统及其算法。</p>
<p>某些存储设备不必很快，三级存储包括光盘、磁带。 存储介质可能是WORM（只写一次，多次读取）或RW（可读写）。 虽然对系统性能不是至关重要的，但仍然需要进行管理，包括挂载和卸载、分配和释放，以及将数据从二级存储迁移到三级存储。</p>
<h4 id="caching">Caching<a hidden class="anchor" aria-hidden="true" href="#caching">#</a></h4>
<ol>
<li>缓存旨在将正在使用的信息从较慢的存储复制到较快的存储中，以提高数据处理速度。</li>
<li>缓存应用于多个计算机层次，包括硬件、操作系统和软件。主内存被视为辅助存储的最后一级缓存。</li>
<li>系统在访问数据前会首先检查缓存，若信息已存在，则直接从缓存中获取；若不存在，则将数据复制到缓存并在其中使用。</li>
<li>由于缓存容量有限，缓存管理策略（如数据替换算法）和设计决策（如缓存大小）至关重要。<br>
具体类型如下：</li>
</ol>
<ul>
<li>磁盘缓存（Disk Cache）：
<ul>
<li>利用主内存的一部分作为缓冲区，临时存储磁盘数据。</li>
<li>磁盘写入时进行聚类，预计会再次被引用的数据可以从软件缓存中快速检索，避免从磁盘缓慢读取。</li>
</ul>
</li>
<li>缓存内存（Cache Memory）：
<ul>
<li>对操作系统不可见，由硬件直接管理。</li>
<li>提高内存速度，缓解处理器速度与内存速度之间的差距。</li>
<li>作为处理器的高速存储区域，提高数据访问效率。</li>
</ul>
</li>
</ul>
<h2 id="operating-system-structure">Operating-System Structure<a hidden class="anchor" aria-hidden="true" href="#operating-system-structure">#</a></h2>
<h3 id="uniprogramming">Uniprogramming<a hidden class="anchor" aria-hidden="true" href="#uniprogramming">#</a></h3>
<p>Uniprogramming（单道批处理系统）是一种计算机操作系统的早期模式，其中在计算机系统上一次只能执行一个程序。这种模式通常是单任务操作系统的基础，它允许计算机执行一个程序，直到该程序完成或发生错误。一旦程序执行完毕，用户可以手动或通过重启系统来加载和执行下一个程序。</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/image-20231020235850374.png"
	
	
	
	loading="lazy"
	
		alt="image-20231020235850374"
	
	
></p>
<p>Uniprogramming的特点包括：</p>
<ol>
<li><strong>单道性：</strong> 计算机一次只能执行一个程序。</li>
<li><strong>简单性：</strong> 由于只有一个程序在运行，Uniprogramming系统相对简单，不需要复杂的任务调度或多任务管理机制。</li>
<li><strong>顺序性：</strong> 资源（如内存和CPU时间）完全由当前运行的程序占用，而其他程序必须等待。</li>
</ol>
<p>Uniprogramming有一些明显的局限性。最显著的是效率问题，因为计算机在执行一个程序时，其他程序无法运行，导致资源利用率低下。此外，用户体验也受到影响，因为用户必须等待一个程序完成后才能运行下一个程序。
这包括：</p>
<ol>
<li><strong>性能低下：</strong> 由于Uniprogramming一次只能执行一个程序，因此性能有限，计算机不能同时处理多个任务，导致了性能低下的问题。</li>
<li><strong>I/O速度慢：</strong> 输入/输出操作的速度较慢，因为计算机必须等待I/O指令完成后才能继续执行。这意味着I/O操作会阻塞其他计算任务的执行。</li>
</ol>
<h3 id="multiprogramming">Multiprogramming<a hidden class="anchor" aria-hidden="true" href="#multiprogramming">#</a></h3>
<ol>
<li><strong>保持CPU和I/O设备始终繁忙：</strong> 多道程序设计旨在最大程度地利用计算机资源，以确保CPU和I/O设备在任何给定时间都保持繁忙状态，以提高系统的性能和资源利用率。</li>
<li><strong>组织作业以保持CPU繁忙：</strong> 多道程序设计将不同的作业（包括代码和数据）组织在系统中，以确保CPU始终有一个作业可供执行，从而减少CPU空闲时间。</li>
<li><strong>内存中的作业子集：</strong> 系统中只保留了作业的一个子集（通常是部分作业）在内存中，以便它们可以立即被执行。</li>
<li><strong>作业调度：</strong> 作业调度是多道程序设计的一部分，它选择要在CPU上运行的作业。作业调度算法根据不同的策略选择下一个要执行的作业。</li>
<li><strong>等待I/O时切换作业：</strong> 当一个作业需要等待I/O操作完成时，操作系统会将CPU的控制权切换到另一个可执行的作业，以充分利用CPU时间，而不让CPU处于空闲状态。</li>
<li><strong>两个程序的多道程序设计：</strong> 这是多道程序设计的一种特定情况，其中只有两个程序同时存在在内存中，操作系统可以根据需要在这两个程序之间切换，以确保CPU忙碌。</li>
</ol>
<p>多道程序设计的核心思想是在系统中同时运行多个作业，以减少计算机资源的浪费，提高性能和响应速度。这种方法允许计算机在一个作业等待I/O操作的时候，执行另一个可执行的作业，从而最大化了资源的利用率。</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/image-20231021000623932.png"
	
	
	
	loading="lazy"
	
		alt="image-20231021000623932"
	
	
></p>
<h3 id="time-sharing-systems">Time sharing systems<a hidden class="anchor" aria-hidden="true" href="#time-sharing-systems">#</a></h3>
<ol>
<li><strong>时间共享和交互式计算</strong>：时间共享系统通过频繁地在不同作业之间切换CPU，使得多个程序能够似乎同时运行，为用户提供交互式的体验。分时技术，是指把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。</li>
<li><strong>系统响应和进程</strong>：
<ul>
<li>快速响应：为了维持交互性，系统的响应时间必须很短，最好小于1秒。</li>
<li>多进程：每个用户在系统中都有至少一个或多个正在运行的程序，这些程序称为进程。</li>
</ul>
</li>
<li><strong>CPU调度和资源管理</strong>：
<ul>
<li>当多个进程同时请求CPU时，需要一个调度机制来决定哪个进程应该获得CPU。</li>
<li>不所有进程都能完全装入内存。当内存不足时，某些进程会被移到磁盘上，需要时再被调入内存。这种操作称为交换，由交换程序（Swapper）执行。</li>
<li>虚拟内存允许不完全在内存中的进程执行，提高了内存的使用效率。</li>
</ul>
</li>
<li><strong>多用户系统和在线通信</strong>：
<ul>
<li>多个用户可以同时使用计算机并运行自己的程序。</li>
<li>用户可以通过终端与系统实时通信，发送命令和接收响应。</li>
<li>与传统的从外部设备（如卡片阅读机）获取指令不同，现代操作系统直接从用户键盘获取指令。</li>
</ul>
</li>
<li><strong>在线系统的可用性</strong>：在线系统必须始终可用，以供用户随时访问数据和代码。</li>
</ol>
<h3 id="real-time-operating-system">Real-time operating system<a hidden class="anchor" aria-hidden="true" href="#real-time-operating-system">#</a></h3>
<p>实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。</p>
<ul>
<li>经常用作专用应用中的控制设备，例如控制科学实验、医学成像系统、工业控制系统以及某些显示系统。</li>
<li>具有明确固定的时间约束。</li>
<li>必须在定义的约束内完成处理，否则系统将失败。</li>
<li>实时系统有两类：
<ul>
<li>硬实时系统
<ul>
<li>目标：保证关键任务及时完成。</li>
<li>次要存储有限或不存在，数据存储在短期内存或只读内存（ROM）中。</li>
<li>与时间共享系统冲突，不被通用操作系统支持。</li>
</ul>
</li>
<li>软实时系统
<ul>
<li>关键实时任务优先于其他任务，并保持该优先级直到完成。</li>
<li>缺乏截止时间支持，在工业控制或机器人技术中应用受限。</li>
<li>在需要高级操作系统功能的应用中有用（例如多媒体、虚拟现实、科学项目）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="operating-system-operations">Operating-System Operations<a hidden class="anchor" aria-hidden="true" href="#operating-system-operations">#</a></h2>
<ul>
<li>Modern operating systems are interrupt driven.</li>
<li>Interrupt driven by hardware</li>
<li>Software error or request creates exception or trap
<ul>
<li>Division by zero, request for operating system service</li>
</ul>
</li>
<li>Other process problems include infinite loop, processes modifying each other or the operating system</li>
</ul>
<h3 id="dual-mode-operation">Dual-mode operation<a hidden class="anchor" aria-hidden="true" href="#dual-mode-operation">#</a></h3>
<p>Dual-mode operation allows OS to protect itself and other system components.</p>
<h4 id="user-mode-and-kernel-mode">user mode and kernel mode<a hidden class="anchor" aria-hidden="true" href="#user-mode-and-kernel-mode">#</a></h4>
<ol>
<li>两种操作模式：
<ul>
<li>User mode：代表用户执行，主要用于普通应用程序的运行。</li>
<li>Kernel mode：代表操作系统执行，用于处理操作系统内核及相关功能。</li>
</ul>
</li>
<li>内核组成部分：
<ul>
<li>硬件密切相关的模块：时钟管理、中断处理等。</li>
<li>运行频率较高的程序：进程管理、设备管理等。</li>
</ul>
</li>
<li>操作系统内核主要包括以下几个方面：
<ul>
<li>时钟管理：计算机最关键的设备，系统管理依赖于时钟。</li>
<li>中断机制：现代操作系统靠中断驱动。</li>
<li>原语Atomic Operation：特殊程序，运行具有原子性。</li>
<li>数据结构管理：操作系统需对系统中的数据结构进行有效管理，包括进程管理、存储器管理、设备管理等。</li>
</ul>
</li>
<li>在用户态和核心态发生的事件
<ol>
<li>核心态
<ol>
<li>系统调用</li>
<li>中断
<ol>
<li>输入输出指令会引起中断</li>
<li>操作系统会完成：提供中断服务、初始化中断向量表、保存中断屏蔽字</li>
</ol>
</li>
<li>时钟
<ol>
<li>置时钟指令只能在核心态运行</li>
</ol>
</li>
</ol>
</li>
<li>用户态
<ol>
<li>用户程序在用户态下使用特权指令引起的中断叫访管中断</li>
<li>访管仅在用户态执行</li>
</ol>
</li>
</ol>
</li>
<li>用户态到核心态的转换是通过硬件完成的</li>
</ol>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/image-20231021104643987.png"
	
	
	
	loading="lazy"
	
		alt="image-20231021104643987"
	
	
>
用户设计程序时，使用系统调用命令，该命令经过编译之后，形成若干参数和陷入（trap）指令。</p>
<h4 id="implementation-of-dual-mode-operation">Implementation of Dual-mode operation<a hidden class="anchor" aria-hidden="true" href="#implementation-of-dual-mode-operation">#</a></h4>
<p>双模态是由操作系统和硬件一起实现的，硬件主要实现下面的功能：</p>
<ol>
<li><strong>特权指令</strong>
<ul>
<li>特权指令：只能在 CPU 处于<u>内核态</u>时执行，具有较高的权限，可以访问和控制系统的硬件资源。
<ul>
<li>特权指令包括危险的指令，如 <u>I/O 指令、置中断指令、存取用于内存保护的寄存器</u>等。</li>
<li>为了防止用户程序对系统造成破坏，特权指令<u>不允许用户直接执行</u>，操作系统提供了接口（称为系统调用）来协助用户执行特权指令。  （系统调用命令工作在内核态）</li>
</ul>
</li>
<li>非特权指令：在 CPU 的 <u>user 态和 kernel 态</u>下执行，主要访问用户的地址空间，权限较低。
<ul>
<li>非特权指令允许用户直接使用，主要访问用户的地址空间，不能直接访问系统中的软硬件资源。</li>
<li>非特权指令在用户程序中广泛应用，用于实现程序的控制逻辑、数据计算和存储等操作。</li>
</ul>
</li>
<li>操作系统在内存中划分用户态内存和内核态内存，并设置各自的特权级别。内核态内存特权级别较高，用于操作系统及其组件的运行；用户态内存特权级别较低，用于用户程序的运行。</li>
<li>用户程序在访问内存时，CPU 会进行特权级检查。当用户程序试图访问特权级别高于自身的内存区域时，CPU 会拒绝执行该指令，从而实现操作系统的保护机制。</li>
<li>特权级检查通过 CPU 提供的特权环机制实现。特权环是一种硬件机制，用于在执行指令时进行特权级检查，以确保程序在适当的权限级别下运行。</li>
<li>特权级检查涉及两个重要数值：当前特权级（CPL）和描述符特权级（DPL）。CPL 表示当前执行指令的特权级，DPL 表示目标内存区域的特权级，二者用于判断程序是否具有访问目标内存的权限。</li>
</ul>
</li>
<li>内存保护
<ul>
<li>保证物理地址与虚拟地址隔离，现代操作系统采用分页法。分页法涉及虚拟地址到物理地址的转换，由硬件（CPU 中的 MMU）执行映射，操作系统决定映射策略，页表存储在内存中。</li>
</ul>
</li>
<li>时间片中断
<ul>
<li>一个让操作系统重新获取CPU控制权的方式。</li>
<li>在定时器中断后，操作系统安排另一个进程（可能是被中断的同一个进程）运行。</li>
<li>为了防止无限循环或进程占用过多资源，操作系统使用计时器，在特定时间后设置中断，不断递减计数器以追踪时间，并在计数器归零时产生中断，从而使操作系统能够重新获得控制权或终止超出分配时间的程序，同时确保修改计时器内容的指令是特权且安全的。</li>
</ul>
</li>
<li>上下文切换
<ul>
<li>当一个进程被替换并由另一个进程取代时，系统保存当前进程的状态并加载新进程的状态。</li>
</ul>
</li>
</ol>
<h3 id="interruption">Interruption<a hidden class="anchor" aria-hidden="true" href="#interruption">#</a></h3>
<p>When an interrupt or fault occurs hardware switches to kernel mode.
<img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/image-20231021104445208.png"
	
	
	
	loading="lazy"
	
		alt="image-20231021104445208"
	
	
></p>
<p>中断是唯一让用户态切换到核心态的方式；
核心态转换为用户态只需要修改<strong>程序状态字PSW的标志位</strong>（通过执行特权指令来修改）；
发生中断或异常时，运行用户态的CPU会立即进入核心态，这是通过硬件实现的（一位寄存器0表示核心态、1表示用户态）</p>
<h4 id="defining-interruption">Defining Interruption<a hidden class="anchor" aria-hidden="true" href="#defining-interruption">#</a></h4>
<ul>
<li>中断也称外中断（外设请求、人工干预），指来自CPU执行指令以外的事件发生（I/O中断、时钟中断），这一类中断通常是与当前指令执行无关的事件；
<ul>
<li>访管中断，又称软件中断或自愿中断，是一种由用户程序在运行过程中主动请求操作系统提供服务而引发的中断。</li>
<li>访管在用户态使用。</li>
<li>外部中断：也称为硬件中断，是由外部设备或硬件信号引发的中断。例如，I/O 设备完成数据传输、硬件故障、计时器到期等。外部中断通常使用中断向量表中的中断向量来处理。
<ul>
<li>处理外部中断时，应由操作系统保存通用寄存器里的内容。</li>
<li>定时器产生时钟中断时，由时钟中断服务程序更新的部分是内核中时钟变量的值、当前进程占用的CPU时间、当前进程在时间片内剩余执行时间。</li>
</ul>
</li>
</ul>
</li>
<li>异常也称内中断（例外、陷入），指来自CPU执行指令内部的事件（程序非法操作码、地址越界），对异常的处理通常依赖当前程序的运行现场，且异常不能被屏蔽，一旦出现应当立即处理；</li>
</ul>
<p>开中断（Enabling Interrupts）：这是指允许中断信号被处理的状态。当系统处于“开中断”状态时，如果出现中断信号，CPU将响应这个信号，并根据中断的类型执行相应的中断处理程序。这是计算机正常操作时的常态，因为它允许系统对如输入/输出请求、硬件故障等事件做出及时响应。</p>
<p>关中断（Disabling Interrupts）：这是指暂时屏蔽或禁止中断信号的状态。在“关中断”状态下，即使有中断信号产生，CPU也不会对其进行处理。这通常用于保护关键的代码段不被中断，例如在操作系统内核执行一些关键任务时，可能会暂时关中断，以保证任务的连续性和数据的一致性。完成这些关键任务后，系统通常会重新开启中断。</p>
<h2 id="computer-system-organization">Computer-System Organization<a hidden class="anchor" aria-hidden="true" href="#computer-system-organization">#</a></h2>
<h3 id="computer-system-operation">Computer-System Operation<a hidden class="anchor" aria-hidden="true" href="#computer-system-operation">#</a></h3>
<p>在计算机系统中，CPU 与 I/O 设备可以同时执行任务，实现高效的数据传输。设备控制器负责管理特定类型的设备，并具备本地缓冲区。CPU 负责在主内存与本地缓冲区之间传输数据，而 I/O 操作则从设备到控制器本地缓冲区进行。当设备控制器完成操作时，它会通过引发中断通知 CPU，从而实现顺畅的数据处理和设备控制。这种机制使得计算机系统能够在处理数据和控制设备时保持高效和稳定。</p>
<h4 id="interrupt-timeline">Interrupt Timeline<a hidden class="anchor" aria-hidden="true" href="#interrupt-timeline">#</a></h4>
<p>&ldquo;Interrupt Timeline&rdquo;（中断时间线）通常指的是计算机系统中的中断事件序列，记录了中断的发生时间和处理时间。在操作系统和计算机体系结构中，中断是一种用于处理异步事件的机制，例如硬件故障、外部设备的输入、定时器事件等。中断允许计算机系统在正常执行的过程中响应和处理这些事件，而不需要等待或轮询。</p>
<p>Interrupt Timeline包括以下关键元素：</p>
<ol>
<li>中断源：表示引发中断事件的来源，例如硬件故障、I/O设备请求、时钟中断等。</li>
<li>中断请求时间：指中断事件发生的确切时间戳。</li>
<li>中断处理时间：指操作系统或处理器开始处理中断事件的时间戳。这包括了操作系统的中断服务例程或中断处理程序的执行时间。</li>
<li>中断完成时间：指整个中断处理过程完成的时间戳。这包括了中断服务例程的执行以及可能的上下文切换。</li>
</ol>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/image-20231020235732529.png"
	
	
	
	loading="lazy"
	
		alt="image-20231020235732529"
	
	
></p>
<h3 id="storage-structure">Storage Structure<a hidden class="anchor" aria-hidden="true" href="#storage-structure">#</a></h3>
<ul>
<li>Main memory &ndash; only large storage area that the processor can access directly.</li>
<li>Secondary storage &ndash; extension of main memory that provides large nonvolatile storage capacity.</li>
<li>Magnetic disks &ndash; rigid metal or glass platters covered with magnetic recording material.
<ul>
<li>Disk surface is logically divided into tracks, which are subdivided into sectors.</li>
<li>The disk controller determines the logical interaction between the device and the computer.</li>
</ul>
</li>
<li>Magnetic tapes &ndash; used for backup, for storage of infrequently used information.</li>
</ul>
<h4 id="storage-hierarchy">Storage Hierarchy<a hidden class="anchor" aria-hidden="true" href="#storage-hierarchy">#</a></h4>
<ul>
<li>Storage systems organized in hierarchy.
<ul>
<li>Speed</li>
<li>Cost</li>
<li>Volatility</li>
</ul>
</li>
<li>Volatile storage loses its contents when the power to the device is removed.</li>
<li>Principle of design a computer memory system：
<ul>
<li>uses only as much expensive memory as necessary.</li>
<li>provides as much inexpensive, nonvolatile memory as possible.</li>
</ul>
</li>
</ul>
<h4 id="storage-device-hierarchy">Storage-Device Hierarchy<a hidden class="anchor" aria-hidden="true" href="#storage-device-hierarchy">#</a></h4>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/image-20231020220210038.png"
	
	
	
	loading="lazy"
	
		alt="image-20231020220210038"
	
	
></p>
<h3 id="io-structure">I/O Structure<a hidden class="anchor" aria-hidden="true" href="#io-structure">#</a></h3>
<ul>
<li>
<p>Programmed I/O</p>
</li>
<li>
<p>Interrupt-Driven I/O</p>
<ul>
<li>
<p>Synchronous I/O</p>
</li>
<li>
<p>Asynchronous I/O</p>
</li>
</ul>
</li>
<li>
<p>DMA</p>
</li>
<li>
<p>I/O通道控制方式</p>
</li>
</ul>
<h4 id="io-operation">I/O operation<a hidden class="anchor" aria-hidden="true" href="#io-operation">#</a></h4>
<ul>
<li><strong>设备控制器</strong> device controller
<ul>
<li>Local buffer storage</li>
<li>A set of special-purpose registers</li>
<li>Moving data between device and its local buffer storage.</li>
<li>设备控制器是一种硬件组件，用于管理特定类型的外部设备（如磁盘驱动器、键盘、鼠标等）。它包括一组特殊用途的寄存器，用于控制设备的操作和状态。设备控制器还包括本地缓冲存储，用于在设备和计算机之间传输数据。</li>
</ul>
</li>
<li><strong>设备驱动程序</strong> device driver
<ul>
<li>One for each device controller.</li>
<li>Presents a uniform interface to the device.</li>
<li>设备驱动程序是用于与设备控制器通信的软件组件。每种设备控制器都有一个相应的设备驱动程序。设备驱动程序提供了一个统一的接口，以便操作系统可以与不同类型的设备进行交互。</li>
</ul>
</li>
<li><strong>I/O 操作</strong> I/O operation ：I/O 操作是指计算机系统与外部设备之间的数据传输和交互过程。它包括以下步骤：
<ul>
<li>Device driver loads registers within the controller. 设备驱动程序加载设备控制器内的寄存器，以配置设备的操作。</li>
<li>Device controller examines the contents of the registers to determine what action to take. 设备控制器检查寄存器的内容，以确定应采取什么操作。</li>
<li>Device controller starts the transfer of data between the device and its local buffer. 设备控制器开始在设备和其本地缓冲存储之间传输数据。</li>
<li>Once done, device controller sets its status, or informs the driver via an interrupt. 一旦完成数据传输，设备控制器设置其状态，或者通过中断通知设备驱动程序。</li>
<li>Device driver returns control to the OS, with data if &lsquo;read&rsquo;. 设备驱动程序将控制返回给操作系统，如果是“读”操作，可能会将读取的数据一并返回。</li>
</ul>
</li>
</ul>
<h4 id="modern-computer-system">Modern Computer System<a hidden class="anchor" aria-hidden="true" href="#modern-computer-system">#</a></h4>
<ul>
<li>high-end systems use switch architecture.</li>
<li>multiple components can talk to other components concurrently, rather than competing for cycles on a shared bus.</li>
</ul>
<p>在计算机系统中，高端系统采用了一种称为&quot;交换架构&quot;的设计。这种设计允许多个系统组件同时相互通信，而不是竞争共享总线周期。在传统的计算机架构中，多个组件（如CPU、内存、输入/输出设备）必须通过共享总线来访问系统资源，这可能会导致资源争用和性能瓶颈。而交换架构允许各个组件之间以更高效的方式进行通信，从而提高了系统的并发性和性能。</p>
<p>在交换架构中，不同组件之间可以直接建立点对点的连接，而无需通过共享总线进行通信。这种架构通常使用交换网络或高速互连来实现，允许组件之间并行传输数据，提供更大的带宽和更低的延迟。这对于高性能计算、大规模服务器和数据中心等需要处理大量数据并进行高度并发处理的应用非常重要。</p>
<img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/image-20231020235530030.png" alt="image-20231020235530030" style="zoom:50%;" />
<h2 id="protection-and-security">Protection and Security<a hidden class="anchor" aria-hidden="true" href="#protection-and-security">#</a></h2>
<ol>
<li>保护：操作系统中的保护机制控制进程或用户对系统资源的访问，确保资源的安全使用和访问控制。</li>
<li>安全：操作系统需要抵御内部和外部攻击，包括拒绝服务、蠕虫、病毒、身份盗窃和服务盗用等安全威胁。</li>
<li>访问控制：操作系统规定用户对系统的访问权限，以确定用户能够执行的操作。</li>
<li>信息流控制：操作系统控制数据在系统内的流动以及传递给用户的方式。</li>
<li>认证：证明访问控制和信息流控制是否按照规范执行的过程。</li>
<li>系统首先区分用户，以确定谁可以执行什么操作。用户标识（用户 ID、安全 ID）包括用户名和相关编号，每个用户有一个。</li>
<li>用户 ID 与用户的所有文件和进程相关联，以确定访问控制。组标识符（组 ID）允许定义一组用户，并进行管理，然后也与每个进程和文件相关联。</li>
<li>特权提升：操作系统允许用户切换到具有更多权限的有效 ID，以便执行需要更高权限的操作。</li>
</ol>
<h1 id="operating-system-structures">Operating-System Structures<a hidden class="anchor" aria-hidden="true" href="#operating-system-structures">#</a></h1>
<h2 id="operating-system-services">Operating System Services<a hidden class="anchor" aria-hidden="true" href="#operating-system-services">#</a></h2>
<p>操作系统提供了一个程序执行的环境，并向程序和用户提供各种服务。</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20231021220150613.png"
	
	
	
	loading="lazy"
	
		alt="image-20231021220150613"
	
	
></p>
<p>操作系统提供一组服务，旨在满足用户的需求，包括以下功能：</p>
<ol>
<li><strong>用户界面 (UI)：</strong> 操作系统提供不同类型的用户界面，以便用户与计算机系统交互。这包括命令行界面 (CLI)，批处理界面，图形用户界面 (GUI) 等。用户可以通过这些界面执行命令、操作文件和访问系统功能。</li>
<li><strong>程序执行：</strong> 操作系统负责加载程序到内存并执行它。它可以正常或异常地终止程序的执行，以指示是否发生了错误。</li>
<li><strong>I/O 操作：</strong> 操作系统管理输入/输出操作，允许用户访问磁盘上的文件，输出到打印机或屏幕等。这包括文件的读写、目录的创建和删除、文件搜索、权限管理等。</li>
<li><strong>文件系统操作：</strong> 操作系统支持对文件和目录的操作，包括读取和写入文件，创建和删除文件和目录，搜索文件，列出文件信息以及权限管理。</li>
<li><strong>通信：</strong> 进程可以在同一台计算机上或在网络上的不同计算机之间交换信息。这可以通过共享内存、消息传递等方式实现。</li>
<li><strong>错误检测：</strong> 操作系统能够检测硬件、I/O 设备或用户程序中可能发生的错误。对于每种类型的错误，操作系统应采取适当的措施以确保计算的正确性和一致性。</li>
<li><strong>调试功能：</strong> 操作系统提供调试工具，以帮助用户和程序员高效地使用系统。这些工具可以用于识别和解决程序中的错误，从而提高系统的可靠性和稳定性。</li>
</ol>
<p>操作系统还具备一组功能，旨在通过资源共享来确保系统自身的高效运行，这包括以下方面：</p>
<ol>
<li><strong>资源分配：</strong> 当多个用户或多个作业同时运行时，必须为它们分配资源。不同类型的资源需要不同的分配策略，例如 CPU 时间、主内存、文件存储等。某些资源可能需要特殊的分配代码，而其他资源可能使用通用的请求和释放代码，例如 I/O 设备。</li>
<li><strong>记账（Accounting）：</strong> 记账是跟踪用户使用了多少以及什么类型的计算机资源的过程。这有助于了解资源的使用情况，以便进行资源管理和计费。</li>
<li><strong>保护和安全性：</strong> 多用户或网络化计算机系统中存储的信息的所有者可能希望控制该信息的使用。同时运行的进程不应相互干扰。保护涉及确保对系统资源的所有访问都受到控制。系统的安全性要求用户进行身份验证，并扩展到保护外部 I/O 设备免受非法访问尝试的攻击。如果要保护和确保系统的安全性，必须在整个系统中采取预防措施。</li>
</ol>
<p>操作系统提供的服务分为面向客户（命令接口）和面向编程人员（系统调用）。</p>
<ol>
<li><strong>命令接口</strong>：用户通过这些操作命令来组织和控制作业的执行。
<ol>
<li>命令行界面（CLI）和图形用户界面（GUI）属于命令接口</li>
<li>根据控制方式的不同，命令接口可分为两类：
<ol>
<li><strong>脱机控制接口</strong>：也称为批处理命令接口，适用于批处理系统，由一组作业控制命令组成。</li>
<li><strong>联机控制接口</strong>：也称为交互式命令接口，适用于分时或实时系统。用户可以与操作系统进行实时交互，操作系统根据用户的指令实时执行任务。</li>
</ol>
</li>
</ol>
</li>
<li><strong>程序接口</strong>：
<ol>
<li>程序接口指的是操作系统提供给程序员的所有编程接口，包括但不限于<u>系统调用</u>。它还可以包括应用程序接口（APIs）、库函数、框架等。</li>
<li>编程人员使用这些接口请求操作系统服务，实际上就是<strong>系统调用</strong>。当我们说“程序接口是编程人员用来请求操作系统服务的，实际上就是系统调用”的时候，我们是在强调系统调用作为程序接口的一个核心和最直接的部分。</li>
</ol>
</li>
</ol>
<h2 id="user-operating-system-interface">User Operating System Interface<a hidden class="anchor" aria-hidden="true" href="#user-operating-system-interface">#</a></h2>
<h3 id="command-interpreter-cli">Command Interpreter (CLI)<a hidden class="anchor" aria-hidden="true" href="#command-interpreter-cli">#</a></h3>
<p>命令解释程序（Command Interpreter）是用户与操作系统之间的接口。它负责解释用户输入的命令并将其传达给操作系统执行。命令解释程序可以以不同的方式实现，取决于操作系统的设计和类型：</p>
<ol>
<li><strong>内核中实现（例如 MS-DOS）：</strong> 在某些操作系统中，命令解释程序可以直接内置在内核中，这使得它更加紧密地与操作系统集成。</li>
<li><strong>由系统程序实现（例如 Windows / UNIX）：</strong> 在其他操作系统中，命令解释程序是作为系统程序运行的，不在内核中。这种设计允许更灵活地扩展和定制命令解释程序。</li>
<li><strong>Shell（例如 UNIX / Linux）：</strong> 在类UNIX系统中，通常使用一个称为&quot;Shell&quot;的特殊程序来充当命令解释程序。不同的Shell可以有不同的特性和功能，例如Bourne Shell、C Shell等。</li>
</ol>
<p>命令解释程序的主要职责是接收用户输入的命令并执行它。命令可以通过两种方式来实现：</p>
<ul>
<li><strong>内置命令（例如 MS-DOS）：</strong> 一些命令解释程序支持内置命令，这意味着某些命令的实现是直接嵌入到命令解释程序中的。这些命令通常执行速度快，但无法轻松扩展或添加新功能。</li>
<li><strong>系统程序（例如 UNIX）：</strong> 在其他系统中，大多数命令是通过系统程序来实现的，这些程序可以独立于命令解释程序进行开发和维护。这种方法使得添加新功能和扩展系统功能变得更加容易，因为不需要修改命令解释程序本身。</li>
</ul>
<h3 id="graphical-user-interface-gui">Graphical User Interface (GUI)<a hidden class="anchor" aria-hidden="true" href="#graphical-user-interface-gui">#</a></h3>
<p>图形用户界面（Graphical User Interface，GUI）是一种用户友好的桌面元喻界面，通常使用鼠标、键盘和显示器来与计算机进行交互。GUI的特点包括：</p>
<ul>
<li><strong>图标表示文件、程序和操作：</strong> GUI使用图标来代表不同的文件、程序、操作等，使用户可以通过可视化方式来管理和执行任务。</li>
<li><strong>鼠标操作：</strong> 用户可以使用鼠标来点击、拖动、右键单击等与界面中的对象互动，触发不同的操作和功能。</li>
<li><strong>提供信息和选项：</strong> 用户可以通过鼠标操作来获取对象的信息，查看选项，执行功能，等等。</li>
<li><strong>文件夹结构：</strong> GUI通常使用文件夹（也称为目录）来组织文件和数据，用户可以打开文件夹以查看其中的内容，这个操作通常被称为&quot;打开目录&quot;。</li>
</ul>
<p>GUI的概念最早在20世纪70年代初由帕洛阿尔托研究中心（Xerox PARC）发明。现代操作系统通常提供了CLI和GUI两种接口，以满足不同用户的需求。一些相关的系统和信息包括：</p>
<ul>
<li><strong>Microsoft Windows：</strong> Windows操作系统使用GUI界面，但也包含了命令行界面（CLI）。</li>
<li><strong>Apple Mac OS X：</strong> Mac OS X使用名为&quot;Aqua&quot;的GUI界面，底层采用UNIX内核，并提供了多种不同的shell来满足不同的需求。</li>
<li><strong>Unix和Linux：</strong> Unix和Linux系统通常提供CLI界面，并可选择性地提供GUI界面，例如Common Desktop Environment（CDE）、KDE Desktop Environment和GNOME GNU Desktop等。</li>
</ul>
<h2 id="system-calls">System Calls<a hidden class="anchor" aria-hidden="true" href="#system-calls">#</a></h2>
<p>系统调用是操作系统提供的接口，允许应用程序与底层硬件和文件系统交互。</p>
<p>系统调用按照功能可分为以下几类：</p>
<ol>
<li>设备管理：完成设备的请求、释放和启动等功能。</li>
<li>文件管理：完成文件的读、写、创建和删除等功能。</li>
<li>进程控制：完成进程的创建、撤销、阻塞和唤醒等功能。</li>
<li>进程通信：完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理：完成内存的分配、回收以及获取作业占用内存区大小和始址等功能。</li>
</ol>
<p>操作系统内核程序负责处理系统调用，运行在核心态。大多数应用程序通过高级应用程序接口（API）而不是直接的系统调用来访问操作系统的功能。API 提供了一组可供程序员使用的函数，简化了与操作系统交互的过程。操作系统通常使用高级编程语言（如 C/C++）编写，并通过库（如 libc）提供 API，使程序员能够更轻松地访问和利用操作系统的功能。这提高了应用程序的开发和维护效率，同时降低了底层系统调用的复杂性。</p>
<blockquote>
<p>库函数与系统调用的区别和联系:
库函数是语言或应用程序的一部分，可以运行在用户空间中。而系统调用是操作系统的一部分，是内核为用户提供的程序接口，运行在内核空间中，而且许多库函数都会使用系统调用来实现功能。未使用系统调用的库函数，其执行效率通常要比系统调用的高。因为使用系统调用时，需要上下文的切换及状态的转换（由用户态转向核心态）。</p>
</blockquote>
<h3 id="system-call-implementation">System Call Implementation<a hidden class="anchor" aria-hidden="true" href="#system-call-implementation">#</a></h3>
<p>运行时支持系统（run-time support system）提供了一个系统调用接口，它作为与系统调用的连接。
这个接口通常包含在与编译器一起提供的库中，这些库中内置了一组函数。
通常，每个系统调用都与一个数字相关联，系统调用接口维护一个表，根据这些数字进行索引。</p>
<p>系统调用接口的功能包括：</p>
<ul>
<li>拦截API中的函数调用。</li>
<li>调用操作系统中所需的系统调用。</li>
<li>返回系统调用的状态以及任何返回值。</li>
</ul>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20231021220948796.png"
	
	
	
	loading="lazy"
	
		alt="image-20231021220948796"
	
	
></p>
<p>调用者无需了解系统调用的实现方式，或者在执行期间它执行了什么操作。
他们只需要遵守API，并理解作为结果操作系统将执行的操作。
API隐藏了程序员不需要了解的大部分操作系统接口的细节，这些细节由运行时支持库进行管理。</p>
<h3 id="system-call-parameter-passing">System Call Parameter Passing<a hidden class="anchor" aria-hidden="true" href="#system-call-parameter-passing">#</a></h3>
<p>通常，传递给操作系统的信息通常不仅仅是所需的系统调用的标识。所需的信息类型和数量因操作系统和调用而异。</p>
<p>有三种常见的方法用于将参数传递给操作系统：</p>
<ol>
<li>Registers，最简单的方法。</li>
<li>Memory block，参数存储在内存中的块或表中，块的地址作为参数传递给寄存器（Linux 和 Solaris 采用这种方法）。</li>
<li>Stack，程序将参数推送到栈上，由操作系统从栈上弹出。</li>
</ol>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20231021221054409.png"
	
	
	
	loading="lazy"
	
		alt="image-20231021221054409"
	
	
></p>
<h2 id="types-of-system-calls">Types of System Calls<a hidden class="anchor" aria-hidden="true" href="#types-of-system-calls">#</a></h2>
<h3 id="process-control">Process control<a hidden class="anchor" aria-hidden="true" href="#process-control">#</a></h3>
<ul>
<li>进程控制
<ul>
<li><strong>结束、中止、加载和执行进程</strong>：用于管理进程的创建和终止。</li>
<li><strong>创建进程、终止进程</strong>：用于创建和终止进程。</li>
<li><strong>获取进程属性、设置进程属性</strong>：用于获取和设置进程的属性信息。</li>
<li><strong>等待时间、等待事件、信号事件</strong>：用于处理等待时间、事件和信号的操作。</li>
<li><strong>分配和释放内存</strong>：用于管理内存的分配和释放。</li>
<li><strong>内存转储</strong>：在发生错误时将内存内容转储到文件中，以进行故障诊断。</li>
<li><strong>调试器</strong>：用于识别和调试程序中的错误，支持单步执行和监视程序的执行。</li>
<li><strong>锁</strong>：用于管理多个进程之间对共享数据的访问，以确保数据的一致性和互斥访问。</li>
</ul>
</li>
</ul>
<p>fork、exec、wait 和 exit 这四个系统调用是和进程有关的最为重要的四个系统调用：</p>
<ul>
<li><strong>fork</strong> 用来创建进程；</li>
<li><strong>exec</strong> 从磁盘上载入并执行某个可执行程序；</li>
<li><strong>exit</strong> 是进程自己退出时要调用的函数；</li>
<li><strong>wait</strong> 调用的进程会等到子进程退出时才继续执行。</li>
</ul>
<h4 id="fork">fork<a hidden class="anchor" aria-hidden="true" href="#fork">#</a></h4>
<p><code>fork</code> 系统调用的函数原型定义为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">fork</span><span class="p">();</span>
</span></span></code></pre></div><p>这个函数没有参数，调用该函数的进程会再创建一个进程，新创建的进程是原进程的子进程。两个进程都从 <code>fork()</code> 这个地方继续往下执行，并且执行“同样”的代码。但是父进程执行 <code>fork()</code> 会返回子进程的ID，而子进程调用 <code>fork()</code> 会返回0。父子进程正是通过对这个返回值的判断（用if语句）来决定分别执行哪段代码。</p>
<h4 id="exec">exec<a hidden class="anchor" aria-hidden="true" href="#exec">#</a></h4>
<p><code>exec()</code> 系统调用的功能是在当前进程中执行一段新程序，进程的PID保持不变。可以这样形象地理解，一个进程就像一个壳子，在这个壳子里可以装各种可执行代码。<code>fork()</code> 创建了这个壳子，并且将父进程的代码装在这个壳子中执行，而 <code>exec()</code> 是用一个磁盘上的可执行程序（<code>exec()</code> 的参数告诉操作系统是哪个可执行程序）替换了这个壳子里原有的内容。</p>
<p><code>exec()</code> 函数分为两类，分别以 <code>execl</code> 和 <code>execv</code> 开头，其函数原型定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">execl</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filepath</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg2</span><span class="p">,</span> <span class="err">…</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">execlp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argl</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg2</span><span class="p">,</span> <span class="err">…</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">execv</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filepath</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]);</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">execvp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]);</span>
</span></span></code></pre></div><p>这些函数基本上一样，只是 <code>execl</code> 中对应可执行程序入口函数的参数，即其中的 <code>arg1</code>、<code>arg2</code> 等，是一个一个列举出来的，而 <code>execv</code> 是将这些参数组织成一个数组告诉操作系统的。</p>
<h4 id="exit">exit<a hidden class="anchor" aria-hidden="true" href="#exit">#</a></h4>
<p><code>exit()</code> 系统调用用来终止一个进程，在进程中可以显式调用 <code>exit</code> 来终止自己，也可以隐式调用 <code>exit</code>。操作系统在编译 <code>main()</code> 函数时，当遇到 <code>main()</code> 函数的最后一个 <code>}</code> 时会“塞入”一个 <code>exit</code>。</p>
<p><code>exit()</code> 函数的原型定义为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
</span></span></code></pre></div><p><code>exit</code> 中的参数 <code>status</code> 是退出进程返回给其父进程的退出码。同时，退出的进程会向其父进程发送一个 <code>SIGCHILD</code> 信号，一个进程执行 <code>wait</code> 系统调用时就会</p>
<p>暂停自己的执行来等待这个信号。所以 <code>wait</code> 和 <code>exit</code> 合在一起可以完成这样一种进程之间的同步合作：父进程启动了一个子进程，调用 <code>wait</code> 等待子进程执行完毕；子进程执行完毕以后调用 <code>exit</code> 给父进程发送一个信号 <code>SIGCHILD</code>，父进程被唤醒继续执行。</p>
<h4 id="wait">wait<a hidden class="anchor" aria-hidden="true" href="#wait">#</a></h4>
<p><code>wait</code> 系统调用的函数原型定义为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">wait</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">stat_addr</span><span class="p">);</span>
</span></span></code></pre></div><p>其返回值是 <code>exit</code> 子进程的PID，<code>stat_addr</code> 是进程中定义的一个变量，用于存放子进程调用 <code>exit</code> 时的退出码，即 <code>exit</code> 系统调用的参数 <code>status</code>。</p>
<h3 id="file-management">File management<a hidden class="anchor" aria-hidden="true" href="#file-management">#</a></h3>
<ol>
<li><strong>创建文件（Create file）</strong>:
<ul>
<li>用于创建新的文件，分配必要的存储空间和初始化文件属性。</li>
</ul>
</li>
<li><strong>删除文件（Delete file）</strong>:
<ul>
<li>用于移除现有文件，释放其占用的存储空间，并更新文件系统的记录。</li>
</ul>
</li>
<li><strong>打开文件（Open）</strong>:
<ul>
<li>用于打开一个文件以进行读取、写入或其他操作。在文件打开时，操作系统通常会在内部维护一个文件描述符或句柄。</li>
</ul>
</li>
<li><strong>关闭文件（Close）</strong>:
<ul>
<li>在文件操作完成后，关闭文件以释放操作系统维护的资源和句柄。</li>
</ul>
</li>
<li><strong>读取文件（Read）</strong>:
<ul>
<li>用于从文件中读取数据到内存中。</li>
</ul>
</li>
<li><strong>写入文件（Write）</strong>:
<ul>
<li>将内存中的数据写入到文件中。</li>
</ul>
</li>
<li><strong>重新定位文件指针（Reposition）</strong>:
<ul>
<li>改变文件读写操作的当前位置，例如移动到文件的特定位置开始读写操作。</li>
</ul>
</li>
<li><strong>获取文件属性（Get file attributes）</strong>:
<ul>
<li>用于查询文件的属性信息，如大小、创建时间、修改时间、权限等。</li>
</ul>
</li>
<li><strong>设置文件属性（Set file attributes）</strong>:
<ul>
<li>允许修改文件的属性，如更改文件权限、修改时间戳等。</li>
</ul>
</li>
</ol>
<h3 id="device-management-1">Device management<a hidden class="anchor" aria-hidden="true" href="#device-management-1">#</a></h3>
<ol>
<li><strong>请求设备（Request Device）</strong>:
<ul>
<li>用于请求使用特定设备，如磁盘驱动器、打印机等。</li>
</ul>
</li>
<li><strong>释放设备（Release Device）</strong>:
<ul>
<li>用于释放先前请求的设备，使其可供其他进程或任务使用。</li>
</ul>
</li>
<li><strong>读取设备（Read Device）</strong>:
<ul>
<li>用于从设备读取数据，如从硬盘读取数据或从键盘接收输入。</li>
</ul>
</li>
<li><strong>写入设备（Write Device）</strong>:
<ul>
<li>将数据写入设备，例如向硬盘写入数据或向显示器发送数据。</li>
</ul>
</li>
<li><strong>重新定位设备指针（Reposition Device Pointer）</strong>:
<ul>
<li>用于移动设备指针到不同位置，如改变磁盘读写头的位置。</li>
</ul>
</li>
<li><strong>获取设备属性（Get Device Attributes）</strong>:
<ul>
<li>用于获取设备的属性信息，如设备类型、状态、配置参数等。</li>
</ul>
</li>
<li><strong>设置设备属性（Set Device Attributes）</strong>:
<ul>
<li>用于设置设备的属性，如配置参数、状态等。</li>
</ul>
</li>
<li><strong>逻辑附加或分离设备（Logical Attach/Detach Device）</strong>:
<ul>
<li>将设备逻辑连接或分离到系统中，以便程序可以访问它。</li>
</ul>
</li>
</ol>
<p>库函数 <code>printf</code> 和 <code>scanf</code></p>
<ul>
<li>
<p><strong>printf</strong>:</p>
<ul>
<li>用于格式化输出，将数据显示到控制台或其他输出设备。</li>
<li>函数原型：<code>void printf(const char* format, ...);</code></li>
<li>例如：<code>printf(&quot;ID:%d&quot;, 3);</code> 会在屏幕上显示 <code>ID:3</code>。</li>
</ul>
</li>
<li>
<p><strong>scanf</strong>:</p>
<ul>
<li>用于格式化输入，从键盘或其他输入设备读取数据。</li>
<li>函数原型：<code>void scanf(const char* format, ...);</code></li>
<li>例如：<code>scanf(&quot;ID:%d&quot;, &amp;id);</code> 会从用户输入中读取一个整数并存储在变量 <code>id</code> 中。</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>：<code>printf</code> 和 <code>scanf</code> 是标准库函数，不是系统调用。它们在内部可能依赖于系统调用如 <code>write</code> 和 <code>read</code> 来实现对设备的“写”和“读”操作。库函数提供了比系统调用更高级的抽象，使得程序员可以更容易地进行输入输出操作。</p>
<blockquote>
<p>Q：库函数和系统调用的区别在哪里？</p>
<p>A：系统调用是最底层的应用，是面向硬件的。而库函数的调用是面向开发的，相当于应用程序的API接口；
各个操作系统的系统调用是不同的，因此系统调用一般是没有跨操作系统的可移植性，而库函数的移植性良好；
库函数属于过程调用，调用开销小；系统调用需要在用户空间和内核上下文环境切换，开销较大；
库函数调用函数库中的一段程序，这段程序最终还是通过系统调用来实现的；系统调用调用的是系统内核的服务；</p>
</blockquote>
<h3 id="communications">Communications<a hidden class="anchor" aria-hidden="true" href="#communications">#</a></h3>
<ol>
<li><strong>消息传递模型（Message-Passing Model）：</strong> 在消息传递模型中，进程通过操作系统提供的进程间通信（IPC）机制来交换信息。这种模型涉及创建和删除通信连接，以及通过发送和接收消息来进行通信。进程可以使用系统调用来发送消息给其他进程，同时也需要相应的系统调用来接收消息。这种模型通常用于实现进程间的协作和数据传输。</li>
<li><strong>共享内存模型（Shared-Memory Model）：</strong> 在共享内存模型中，进程使用映射内存的系统调用来访问其他进程拥有的内存区域。这允许多个进程在相同的内存区域中读取和写入数据，从而实现了共享数据。进程可以使用系统调用来附加或分离共享内存区域，以便其他进程可以访问它。这种模型通常用于实现高效的数据共享和协作。</li>
</ol>
<h3 id="information-maintenance">Information maintenance<a hidden class="anchor" aria-hidden="true" href="#information-maintenance">#</a></h3>
<h3 id="系统调用概述">系统调用概述<a hidden class="anchor" aria-hidden="true" href="#系统调用概述">#</a></h3>
<ol>
<li>
<p><strong>获取时间或日期（Get Time or Date）</strong>:</p>
<ul>
<li>用于获取当前系统时间或日期。</li>
<li>通常返回时间和日期的详细信息，如年、月、日、小时、分钟、秒等。</li>
</ul>
</li>
<li>
<p><strong>设置时间或日期（Set Time or Date）</strong>:</p>
<ul>
<li>允许设置或修改系统的当前时间和日期。</li>
<li>这通常是一个受保护的操作，可能需要管理员权限或特殊权限。</li>
</ul>
</li>
<li>
<p><strong>获取系统数据（Get System Data）</strong>:</p>
<ul>
<li>用于获取操作系统的各种数据，如系统性能、资源利用率、配置设置等。</li>
</ul>
</li>
<li>
<p><strong>设置系统数据（Set System Data）</strong>:</p>
<ul>
<li>用于修改系统设置或配置。</li>
<li>这些更改可能影响系统的整体行为或性能，通常需要特定权限。</li>
</ul>
</li>
<li>
<p><strong>获取进程、文件或设备属性（Get Process, File, or Device Attributes）</strong>:</p>
<ul>
<li>用于查询进程、文件或设备的特定属性，如进程状态、文件大小、设备类型等。</li>
</ul>
</li>
<li>
<p><strong>设置进程、文件或设备属性（Set Process, File, or Device Attributes）</strong>:</p>
<ul>
<li>允许修改进程、文件或设备的属性。</li>
<li>这可能包括更改进程优先级、修改文件权限、调整设备配置等。</li>
</ul>
</li>
</ol>
<h3 id="protection">Protection<a hidden class="anchor" aria-hidden="true" href="#protection">#</a></h3>
<ol>
<li>
<p><strong>控制资源访问（Control Access to Resources）</strong>:</p>
<ul>
<li>涉及限制对文件、设备、网络资源等的访问。</li>
<li>通常基于用户身份、组成员资格或角色来实现。</li>
</ul>
</li>
<li>
<p><strong>获取和设置权限（Get and Set Permissions）</strong>:</p>
<ul>
<li>用于查询或修改文件、目录或其他系统资源的访问权限。</li>
<li>权限可以包括读取、写入、执行等操作的允许或禁止。</li>
</ul>
</li>
<li>
<p><strong>允许和拒绝用户访问（Allow and Deny User Access）</strong>:</p>
<ul>
<li>用于授权特定用户或用户组访问资源，或者拒绝他们的访问请求。</li>
<li>这涉及到用户账户的管理和权限分配。</li>
</ul>
</li>
</ol>
<h2 id="system-programs">System Programs<a hidden class="anchor" aria-hidden="true" href="#system-programs">#</a></h2>
<p>系统程序是计算机操作系统中的一组程序，用于提供各种服务和功能。</p>
<p><strong>文件管理：</strong></p>
<ul>
<li>创建、删除、复制、重命名、打印、导出、列出文件和目录。</li>
</ul>
<p><strong>状态信息：</strong></p>
<ul>
<li>一些系统程序可以获取系统信息，如日期、时间、可用内存、磁盘空间和用户数量。</li>
<li>其他系统程序提供详细的性能、日志记录和调试信息，通常将输出格式化并显示在终端或其他输出设备上。</li>
<li>一些系统实现了注册表，用于存储和检索配置信息。</li>
</ul>
<p><strong>文件修改：</strong></p>
<ul>
<li>文本编辑器用于创建和修改文件，而特殊命令可搜索文件内容或进行文本转换。</li>
</ul>
<p><strong>编程语言支持：</strong></p>
<ul>
<li>编译器、汇编程序、调试器和解释器有时会提供编程语言支持。</li>
</ul>
<p><strong>程序加载和执行：</strong></p>
<ul>
<li>包括绝对装载程序、可重定位装载程序、链接编辑器和覆盖加载程序等。</li>
<li>还包括用于高级语言和机器语言的调试系统。</li>
</ul>
<p><strong>通信：</strong></p>
<ul>
<li>提供创建进程、用户和计算机系统之间虚拟连接的机制。</li>
<li>允许用户将消息发送到其他用户的屏幕、浏览网页、发送电子邮件、远程登录、在不同机器之间传输文件等。</li>
</ul>
<p><strong>系统实用程序/应用程序：</strong></p>
<ul>
<li>由用户运行，通常不被视为操作系统的一部分。</li>
<li>可通过命令行、鼠标点击或手指触摸等方式启动。</li>
<li>例如，Web浏览器、文字处理器、电子表格、数据库系统、编译器、统计分析软件和游戏等。</li>
</ul>
<p><strong>后台服务：</strong></p>
<ul>
<li>在系统启动时启动，一些在系统启动后终止，一些在系统启动到关机期间一直运行。</li>
<li>提供诸如磁盘检查、进程调度、错误日志记录、打印等功能。</li>
<li>在用户上下文中运行，而非内核上下文中。</li>
<li>通常被称为服务、子系统或守护程序。</li>
</ul>
<h2 id="operating-system-design-and-implementation">Operating System Design and Implementation<a hidden class="anchor" aria-hidden="true" href="#operating-system-design-and-implementation">#</a></h2>
<p>操作系统的设计与实现是一个复杂的任务，没有一个“完美”的解决方案，但一些方法已被证明是成功的。不同操作系统的内部结构可以有很大的差异。</p>
<p><strong>目标与规格定义：</strong></p>
<ul>
<li>操作系统的设计首先需要明确定义目标和规格。这些目标受到硬件选择、系统类型（批处理、分时、实时、单用户或多用户、分布式等）的影响。</li>
</ul>
<p><strong>难以规定的要求：</strong></p>
<ul>
<li>操作系统的需求难以精确定义，因为它们需要满足多方面的用户和系统目标。</li>
<li>用户目标包括方便使用、易学易用、可靠、安全和高效。</li>
<li>系统目标包括易于设计、实现和维护、灵活、可靠、无错误和高效。</li>
<li>规定和设计操作系统是软件工程的高度创造性任务。</li>
</ul>
<p><strong>策略与机制分离：</strong></p>
<ul>
<li>重要原则是将策略与机制分离。</li>
<li>策略是关于“做什么”的问题，而机制是关于“如何做”的问题。</li>
<li>分离策略和机制是一个非常重要的原则，它允许在以后更改策略决策时具有最大的灵活性。</li>
<li>例如，设置时间片长度和给予某些类型的程序优先级就是策略和机制分离的例子。</li>
<li>Unix和Windows的调度策略就是这种分离的例子。</li>
</ul>
<p><strong>多种编程语言的使用：</strong></p>
<ul>
<li>操作系统的实现通常包含多种编程语言的混合使用。</li>
<li>较低层次的部分可能使用汇编语言编写，主体部分通常使用C语言编写。</li>
<li>系统程序可能使用C、C++以及脚本语言（如PERL、Python、Shell脚本）编写。</li>
<li>使用更高级别的语言使操作系统更容易移植到不同的硬件平台，但可能会导致性能较差和存储需求较大。</li>
</ul>
<p><strong>模拟（Emulation）：</strong></p>
<ul>
<li>模拟允许操作系统在非本机硬件上运行。</li>
<li>模拟可以通过模拟硬件或虚拟机来实现。</li>
<li>这样的模拟可以提高操作系统在不同平台上的可移植性。</li>
</ul>
<p><strong>操作系统性能的提升：</strong></p>
<ul>
<li>提高操作系统性能的主要方法包括改进数据结构和算法。</li>
<li>仅有少量代码对于高性能至关重要，包括中断处理程序、I/O管理、内存管理和CPU调度器。</li>
<li>写好并正确运行后，可以识别性能瓶颈的关键例程，然后将其替换为汇编语言等效代码以提高性能。</li>
</ul>
<h2 id="operating-system-structure-1">Operating System Structure<a hidden class="anchor" aria-hidden="true" href="#operating-system-structure-1">#</a></h2>
<h3 id="简单结构-simple-structure">简单结构 Simple structure<a hidden class="anchor" aria-hidden="true" href="#简单结构-simple-structure">#</a></h3>
<h4 id="ms-dos">MS-DOS<a hidden class="anchor" aria-hidden="true" href="#ms-dos">#</a></h4>
<p>MS-DOS（Microsoft Disk Operating System）是为了在最小的空间内提供最大功能而编写的操作系统。它存在一些结构上的不足：</p>
<ol>
<li>
<p><strong>缺乏模块化分割：</strong> MS-DOS没有被精心分割为模块化的组件。这意味着其功能没有被很好地分离和隔离，而是被混杂在一起，这使得系统的维护和扩展变得更加困难。</p>
</li>
<li>
<p><strong>接口和功能的分离问题：</strong> MS-DOS中，接口和功能的分离程度较低。这意味着不同功能的代码没有被清晰地分隔开，这可能导致代码的不稳定性和难以维护。</p>
</li>
<li>
<p><strong>受限于硬件：</strong> MS-DOS在某种程度上受到了硬件的限制。例如，它最初是设计用于Intel 8088处理器，这个处理器缺乏一些现代操作系统所需的功能，比如双模式（用户模式和内核模式）和硬件保护机制。</p>
</li>
</ol>
<p>因此，MS-DOS虽然在其时间内非常重要，但由于结构上的不足，它在面对较新的硬件和复杂的任务时变得不够灵活。这促使了后来的操作系统设计采用更模块化、分层的方法，以提高系统的稳定性和可维护性。</p>
<h4 id="original-unix">Original UNIX<a hidden class="anchor" aria-hidden="true" href="#original-unix">#</a></h4>
<p>原始的UNIX操作系统在结构上较为有限，这主要是由硬件功能的限制所决定的。它由两个可分离的部分组成：</p>
<ol>
<li>
<p><strong>系统程序：</strong> 这部分包括用户可以运行的各种应用程序，如文本编辑器、编译器等。系统程序构成了用户与操作系统交互的一部分。</p>
</li>
<li>
<p><strong>内核：</strong> 内核是操作系统的核心部分，位于系统的最底层。内核被分为一系列接口和设备驱动程序，包括系统调用接口、文件系统、CPU调度、内存管理等功能。内核位于系统调用接口以下，位于物理硬件之上，它为系统提供了基本的操作系统功能。</p>
</li>
</ol>
<p>UNIX操作系统的API（应用程序编程接口）是通过系统调用定义的，而通常可用的系统程序则构成了用户界面。这种结构使得用户可以运行各种程序，而内核负责管理硬件和提供系统服务。</p>
<p>需要注意的是，原始的UNIX操作系统的结构相对简单，这是因为它诞生于较早的计算机时代，当时的硬件功能和资源有限。后来的UNIX变种和其他操作系统采用了更模块化和层次化的结构，以适应更复杂的硬件和应用需求。</p>
<h3 id="分层结构-layered-approach">分层结构 Layered Approach<a hidden class="anchor" aria-hidden="true" href="#分层结构-layered-approach">#</a></h3>
<p>操作系统可以分解成多个层次（或称为层级），每一层建立在较低层次之上。这些层次构成了操作系统的层次结构，其中最底层（第0层）是硬件，而最高层（第N层）是用户界面。</p>
<p>在这种层次结构中，每个操作系统层次都表示一个抽象对象，由数据和可以操作这些数据的函数组成。模块化设计使得每一层次都可以使用较低层次的函数和服务，以构建更高层次的功能。</p>
<p>这种结构使系统各部分相互隔离，降低复杂性，更易于维护和扩展。主要优点是简化系统设计和开发，降低错误风险，更容易扩展和维护，有助于管理复杂性。</p>
<p>将操作系统视为一系列层次结构是一种有助于管理系统复杂性的方法。这个方法的主要思想是将系统的功能和组件分解为多个层次，每个层次负责执行相关的功能，同时依赖于较低层次的功能来完成更基本的操作。这种分解有以下主要优势：</p>
<p>主要优势：</p>
<ol>
<li>构建和调试的简单性：通过将系统划分为多个层次，每个层次有明确定义的功能，使得系统的构建和调试变得更加简单。每个层次都可以独立开发和测试，减少了复杂性。</li>
<li>设计和实施的简化：层次结构化方法有助于将系统的设计和实施任务分解为更小的、可管理的子问题。这种分解有助于管理复杂性，使整个过程更加清晰。</li>
</ol>
<p>主要困难：</p>
<ol>
<li>层次的仔细定义：确定每个层次的功能和接口需要仔细的定义。不同层次之间的依赖性和接口必须清晰明确，以确保系统的正确运行。</li>
<li>复杂性的分层结构：在一些情况下，分层结构可能导致复杂性的增加，尤其是在处理诸如磁盘驱动器和内存管理等关键组件时。这可能需要更复杂的协作和通信。</li>
</ol>
<p>在操作系统中，将其视为一系列层次结构可以帮助管理系统的复杂性，但这种方法可能不如其他结构类型高效。在这种分层结构中，每个层次负责一组相关的功能，而每个系统调用必须经过多个层次才能达到硬件层面，这可能会导致性能开销。以下是有关这一点的详细信息：</p>
<ol>
<li>
<p>效率较低：这种分层结构可能导致系统调用的效率较低。当执行系统调用时，它必须经过多个层次，每个层次可能需要对参数进行修改、传递数据等。这会增加系统调用的开销。</p>
</li>
<li>
<p>举例：考虑执行I/O操作的情况。当应用程序执行I/O操作时，它会触发系统调用，该系统调用被传递到I/O层次。然后，I/O层次可能需要与内存管理层次和CPU调度层次进行通信，最终数据被传递给硬件执行。这些多次通信和数据传递可能导致性能下降。</p>
</li>
<li>
<p>宏内核（Monolithic Kernel）：在宏内核结构中，整个核心操作系统运行在内核空间和监管者模式下。这种结构通常没有明确的层次结构，所有功能都在一个单一的内核中实现。这可能会导致较低的模块化和较高的性能，但也可能增加维护的复杂性。</p>
</li>
</ol>
<p>总的来说，分层结构虽然有助于管理系统复杂性，但可能在性能方面存在一些开销。不同的操作系统采用不同的设计方法，以在性能和复杂性之间取得平衡。对于某些用途，如实时系统，可能更倾向于采用更紧凑的内核结构，而对于通用用途的操作系统，可能更愿意牺牲一些性能以获得更好的可维护性和可扩展性。</p>
<h3 id="微内核结构-microkernels">微内核结构 Microkernels<a hidden class="anchor" aria-hidden="true" href="#微内核结构-microkernels">#</a></h3>
<p>微内核（Microkernel）是一种操作系统设计结构，旨在将操作系统的基本功能模块化，并将尽可能多的功能移到用户空间，以提高系统的模块性、灵活性和可维护性。以下是有关微内核的一些关键概念和优点：</p>
<p><strong>基本功能：</strong> 微内核包含操作系统的基本功能，如内存管理、CPU调度和进程间通信（IPC）。这些功能通常被认为是不可或缺的，但微内核试图将其他功能从内核中分离出来。</p>
<p><strong>用户空间服务：</strong> 微内核将额外的服务移到用户空间中，这些服务可以在用户空间中运行并与客户程序通信。客户程序可以使用这些服务来执行特定任务，而无需直接涉及内核。这提高了系统的可定制性和灵活性。</p>
<p><strong>通信方式：</strong> 微内核系统通常使用消息传递来实现客户程序和用户空间服务之间的通信。消息传递允许客户程序发送请求或数据给服务，并通过消息响应来执行相应的操作。</p>
<p><strong>优点：</strong> 微内核结构的主要优点包括：</p>
<ul>
<li>模块化：它允许操作系统的各个部分相对独立地开发和维护，减少了模块之间的相互影响，提高了可维护性。</li>
<li>灵活性：新的服务可以相对容易地添加到用户空间，而不必更改整个内核，提供了更大的可配置性和扩展性。</li>
<li>安全性和可靠性：微内核的模块化设计使得每个模块都可以进行严格测试，如果一个服务出现问题，不会影响整个操作系统的稳定性。</li>
</ul>
<p>然而，微内核结构可能会导致一定的性能开销，因为消息传递和用户空间切换可能比在内核中执行相同功能更慢。因此，在对性能要求非常高的应用程序中，可能会选择其他内核结构。不同的操作系统采用不同的内核结构，以满足其设计目标和需求。</p>
<p>微内核结构的劣势在于性能可能受到一定的影响，主要表现在以下方面：</p>
<p><strong>系统功能开销增加：</strong> 使用微内核结构会引入更多的系统功能开销，例如消息传递和用户空间切换。这些额外的开销可能会导致性能下降，特别是在对性能要求非常高的应用程序中。</p>
<p><strong>性能历史问题：</strong> 一个明显的例子是Windows NT操作系统的性能历史。最初的Windows NT 1.0采用了分层微内核组织，导致性能较低，与Windows 95相比表现不佳。随后的Windows NT 4.0部分改进了性能问题，将某些层次从用户空间移到内核空间，并更加紧密地集成它们。然而，随着Windows XP的设计，Windows的架构变得更加单片化，不再典型的微内核结构。</p>
<ol>
<li>大内核和微内核
<ol>
<li>大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务；由于复杂的交互关系使得层次之间的界限极其模糊，定义清晰的层次间接口非常困难；</li>
<li>微内核将内核中最基本的功能保留在内核，将那些不需要在核心态执行的功能移到用户态执行；微内核结构最大的问题是性能问题，需要频繁在核心态与用户态之间进行切换；</li>
</ol>
</li>
</ol>
<h3 id="模块化结构-modules">模块化结构 Modules<a hidden class="anchor" aria-hidden="true" href="#模块化结构-modules">#</a></h3>
<p>现代许多操作系统采用可加载的内核模块。内核包含一组核心组件，并通过模块动态链接其他服务，可以在启动时或运行时进行。这种方法在现代UNIX的实现中非常常见，例如Solaris、Linux和Mac OS X，以及Windows。以下是有关可加载内核模块的一些关键概念：</p>
<p><strong>常见性：</strong> 可加载内核模块在现代操作系统中广泛采用，尤其是在UNIX系列操作系统中。</p>
<p><strong>面向对象的方法：</strong> 可加载内核模块采用面向对象的方法。每个核心组件都是独立的模块，它们之间使用已知接口进行通信。</p>
<p><strong>模块化：</strong> 每个核心组件都是可加载的，可以根据需要在内核中加载。这增加了系统的可扩展性和定制性。</p>
<p><strong>受保护接口：</strong> 每个核心组件都有定义的受保护接口，确保安全性和隔离性。</p>
<p><strong>更高的灵活性：</strong> 与微内核结构相似，可加载内核模块具有更高的灵活性，因为任何模块都可以调用其他模块，而不必通过消息传递来进行通信。</p>
<p><strong>更高的效率：</strong> 相对于一些其他结构，可加载内核模块通常更加高效，因为模块之间的通信无需调用消息传递，从而减少了开销。</p>
<p>总的来说，可加载内核模块是一种在现代操作系统中广泛采用的内核结构，它融合了模块化、面向对象和高效的设计原则，以提供更大的灵活性和可扩展性。</p>
<h2 id="virtual-machines">Virtual Machines<a hidden class="anchor" aria-hidden="true" href="#virtual-machines">#</a></h2>
<ul>
<li>
<p><strong>操作系统虚拟化</strong>：</p>
<ul>
<li>通过CPU调度和虚拟内存，操作系统为多个进程创造了在各自处理器上执行以及拥有自己虚拟内存的幻觉。</li>
<li>物理计算机的资源被共享来创建虚拟机。</li>
<li>虚拟机将分层方法推向逻辑极限，将硬件和操作系统内核视为硬件层。</li>
<li>虚拟机提供与裸机硬件相同的接口，允许操作系统作为其他操作系统内的应用程序运行。</li>
<li>虚拟机管理器（VMM）提供虚拟化服务，支持本机编译的客户操作系统运行在本机编译的宿主操作系统上。</li>
<li>在源CPU类型与目标类型不同的情况下，使用模拟，如 &ldquo;Rosetta&rdquo; 允许IBM CPU编译的应用程序在Intel CPU上运行。</li>
</ul>
</li>
<li>
<p><strong>虚拟机特性</strong>：</p>
<ul>
<li>提供了对系统资源的完全保护。</li>
<li>每个虚拟机与所有其他虚拟机隔离，不允许直接共享资源。</li>
<li>系统的开发和测试可在虚拟机上进行，不干扰正常系统操作。</li>
<li>虚拟机的普及解决了系统兼容性问题，但实现复杂，需提供与底层机器完全相同的副本。</li>
</ul>
</li>
<li>
<p><strong>虚拟化方法</strong>：</p>
<ul>
<li><strong>第一类虚拟化</strong>：类似操作系统，运行在裸机上，提供多道程序功能，向上层提供若干台虚拟机，每台都是裸机硬件的精确复制品。支持不同操作系统的运行。</li>
<li><strong>第二类虚拟化</strong>：依赖于宿主操作系统分配和调度资源，伪装成具有CPU和设备的完整计算机。如VMware Workstation。客户操作系统安装在虚拟磁盘上。</li>
</ul>
</li>
<li>
<p><strong>虚拟化应用</strong>：</p>
<ul>
<li>Web主机领域中虚拟化十分流行，提供了成本效益高的解决方案，如“云”主机。</li>
<li>第一类虚拟化也称为裸金属架构，第二类称为寄居架构。</li>
</ul>
</li>
</ul>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/%25E6%2588%25AA%25E5%259B%25BE_20231102170614.png"
	
	
	
	loading="lazy"
	
		alt="截图_20231102170614.png"
	
	
></p>
<h2 id="operating-system-generation">Operating System Generation<a hidden class="anchor" aria-hidden="true" href="#operating-system-generation">#</a></h2>
<h2 id="操作系统生成">操作系统生成<a hidden class="anchor" aria-hidden="true" href="#操作系统生成">#</a></h2>
<p>操作系统的生成是一个定制化和配置过程，用以确保操作系统能够在特定的计算机硬件上运行。</p>
<ol>
<li>
<p><strong>针对特定硬件的设计</strong>：</p>
<ul>
<li>操作系统被设计为能够在某一类计算机硬件上运行。</li>
<li>需要对每个具体的计算机站点进行详细配置。</li>
</ul>
</li>
<li>
<p><strong>系统生成程序（SYSGEN）</strong>：</p>
<ul>
<li>SYSGEN 程序用于获取硬件系统的特定配置信息。</li>
<li>这些信息帮助操作系统更好地理解并适应当前的硬件环境。</li>
</ul>
</li>
<li>
<p><strong>系统生成的方法</strong>：</p>
<ul>
<li><strong>修改操作系统源代码</strong>：根据具体硬件需求调整操作系统的源代码副本。</li>
<li><strong>预编译库选择</strong>：从预编译的库中创建表格并选择适合的模块。</li>
<li><strong>表格驱动系统</strong>：创建适当的表格以描述系统配置，系统完全由这些表格驱动。</li>
<li><strong>执行时选择</strong>：系统在运行时根据这些表格进行配置选择和调整。</li>
</ul>
</li>
</ol>
<h2 id="system-boot">System Boot<a hidden class="anchor" aria-hidden="true" href="#system-boot">#</a></h2>
<h3 id="操作系统引导过程">操作系统引导过程<a hidden class="anchor" aria-hidden="true" href="#操作系统引导过程">#</a></h3>
<p>操作系统引导是计算机启动和加载操作系统的一系列过程。这个过程涉及多个步骤，确保硬件和软件正确地协同工作，从而启动计算机系统。以下是引导过程的详细步骤：</p>
<ol>
<li>
<p><strong>激活CPU</strong>:</p>
<ul>
<li>CPU被激活并读取ROM中的引导程序（Boot Program）。</li>
<li>将指令寄存器设置为BIOS（基本输入输出系统）的第一条指令，开始执行BIOS。</li>
</ul>
</li>
<li>
<p><strong>硬件自检</strong>:</p>
<ul>
<li>BIOS启动后，首先进行硬件自检（POST - Power-On Self Test）。</li>
<li>检查硬件是否存在故障，如有故障，主板会发出警告声，启动中止。</li>
<li>若无故障，屏幕显示CPU、内存、硬盘等硬件信息。</li>
</ul>
</li>
<li>
<p><strong>加载操作系统所在的硬盘</strong>:</p>
<ul>
<li>BIOS读取Boot Sequence（启动顺序），这通常保存在CMOS中，或通过用户交互设置。</li>
<li>控制权传递给启动顺序中排在第一位的存储设备。</li>
<li>CPU将该存储设备的引导扇区内容加载到内存中。</li>
</ul>
</li>
<li>
<p><strong>加载主引导记录（MBR）</strong>:</p>
<ul>
<li>主引导记录（MBR）位于硬盘的第一个扇区。</li>
<li>MBR包含特定标识符，区分引导硬盘和非引导硬盘。</li>
<li>MBR的作用是告诉CPU去哪个主分区找操作系统。</li>
</ul>
</li>
<li>
<p><strong>扫描硬盘分区表，加载活动分区</strong>:</p>
<ul>
<li>MBR包含硬盘分区表，该表区分活动分区和非活动分区。</li>
<li>MBR扫描分区表，识别含有操作系统的硬盘活动分区。</li>
<li>找到活动分区后，开始加载，将控制权交给该分区。</li>
</ul>
</li>
<li>
<p><strong>加载分区引导记录（PBR）</strong>:</p>
<ul>
<li>读取活动分区的第一个扇区，即分区引导记录（PBR）。</li>
<li>PBR的作用是找到并激活用于引导操作系统的程序（如启动管理器）。</li>
</ul>
</li>
<li>
<p><strong>加载启动管理器</strong>:</p>
<ul>
<li>分区引导记录搜索并加载活动分区中的启动管理器。</li>
</ul>
</li>
<li>
<p><strong>加载操作系统</strong>:</p>
<ul>
<li>启动管理器进一步加载操作系统，完成引导过程。</li>
</ul>
</li>
</ol>
<p>这个过程是操作系统启动和运行的基础，确保了从硬件的初始化到操作系统完全加载的顺利进行。</p>

</section>


    <footer class="article-footer">
    

    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.8/katex.min.css"crossorigin="anonymous"
            ><script 
                src="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.8/katex.min.js"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.8/contrib/auto-render.min.js"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
        &copy; 
        
        2024 Bethel<br>共 97.40k 字 · 共 10 篇文章
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://stack.jimmycai.com/" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> 由 <a href="https://jimmycai.com/" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script><script type="text/javascript" src="/ts/custom.js" defer></script>


<script src="https://mecdn.mcserverx.com/gh/zhixuan2333/gh-blog/master/js/nprogress.min.js" integrity="sha384-bHDlAEUFxsRI7JfULv3DTpL2IXbbgn4JHQJibgo5iiXSK6Iu8muwqHANhun74Cqg" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://mecdn.mcserverx.com/gh/zhixuan2333/gh-blog/master/css/nprogress.css" integrity="sha384-KJyhr2syt5+4M9Pz5dipCvTrtvOmLk/olWVdfhAp858UCa64Ia5GFpTN7+G4BWpE" crossorigin="anonymous" />
<script>
    NProgress.start();
    document.addEventListener("readystatechange", () => {
        if (document.readyState === "interactive") NProgress.inc(0.8);
        if (document.readyState === "complete") NProgress.done();
    });
</script>
    </body>
</html>
