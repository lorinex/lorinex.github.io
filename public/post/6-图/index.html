<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='图 图的定义和术语 定义 是由顶点集合和一个描述顶点之间关系&amp;mdash;-边的集合组成 Graph=(V,E) V：顶点(数据元素)的有穷非空集合。 E：边的有穷集合。 相'>
<title>6 图 | Bethel's Blog</title>

<link rel='canonical' href='http://localhost:1313/post/6-%E5%9B%BE/'>

<link rel="stylesheet" href="/scss/style.min.c3c7ecff622b4ad3ac6aacf17244c017cc674f0e82b470bfb8f4de85243313d0.css"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"K3aYNEt3ZeYoZwhE",ck:"K3aYNEt3ZeYoZwhE"})</script>
<script async src="https://umami.xalaok.top/uanalytics" data-website-id="095ee454-e560-4d9b-bf1c-869f8529c17f"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//instant.page/5.2.0" type="module" integrity="sha384-jnZyxPjiipYXnSU0ygqeac2q7CVYMbh84q0uHVRRxEtvFPiQYbXWUorga2aqZJ0z"></script><meta property='og:title' content='6 图'>
<meta property='og:description' content='图 图的定义和术语 定义 是由顶点集合和一个描述顶点之间关系&amp;mdash;-边的集合组成 Graph=(V,E) V：顶点(数据元素)的有穷非空集合。 E：边的有穷集合。 相'>
<meta property='og:url' content='http://localhost:1313/post/6-%E5%9B%BE/'>
<meta property='og:site_name' content='Bethel'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-01-22T13:37:43&#43;00:00'/><meta property='article:modified_time' content='2024-01-22T13:37:43&#43;00:00'/>
<meta name="twitter:title" content="6 图">
<meta name="twitter:description" content="图 图的定义和术语 定义 是由顶点集合和一个描述顶点之间关系&amp;mdash;-边的集合组成 Graph=(V,E) V：顶点(数据元素)的有穷非空集合。 E：边的有穷集合。 相">
    <link rel="shortcut icon" href="/favicon.png" />
<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/lxgwwenkaigbscreen.css" />
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/tx_hu92c04046da3d4074953cad185e3935e5_62559_300x0_resize_q75_box.jpg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Bethel</a></h1>
            <h2 class="site-description">Live and learn. ✍️</h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>首页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
                <li id="i18n-switch">  
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                    <select name="language" onchange="window.location.href = this.selectedOptions[0].value">
                        
                            <option value="http://localhost:1313/" selected></option>
                        
                    </select>
                </li>
            
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-sun-high" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M14.828 14.828a4 4 0 1 0 -5.656 -5.656a4 4 0 0 0 5.656 5.656z" />
  <path d="M6.343 17.657l-1.414 1.414" />
  <path d="M6.343 6.343l-1.414 -1.414" />
  <path d="M17.657 6.343l1.414 -1.414" />
  <path d="M17.657 17.657l1.414 1.414" />
  <path d="M4 12h-2" />
  <path d="M12 4v-2" />
  <path d="M20 12h2" />
  <path d="M12 20v2" />
</svg>
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-moon-stars" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
  <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" />
  <path d="M19 11h2m-1 -1v2" />
</svg>
                    <span>深色模式</span>
                </li>
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#图的定义和术语">图的定义和术语</a>
      <ol>
        <li><a href="#定义">定义</a></li>
        <li><a href="#相关术语">相关术语</a></li>
        <li><a href="#图的基本操作">图的基本操作</a></li>
      </ol>
    </li>
    <li><a href="#图的存储结构">图的存储结构</a>
      <ol>
        <li><a href="#1数组邻接矩阵-表示法adjacency-matrix顺序存储方式">1.数组/邻接矩阵 表示法(Adjacency Matrix)顺序存储方式</a>
          <ol>
            <li><a href="#邻接矩阵存储方法的特点">邻接矩阵存储方法的特点</a></li>
          </ol>
        </li>
        <li><a href="#2邻接表adjacency-list-----顺序存储链式存储">2.邻接表(Adjacency List)     顺序存储+链式存储</a>
          <ol>
            <li><a href="#有向图的逆邻接表">有向图的逆邻接表</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#图的遍历">图的遍历</a>
      <ol>
        <li><a href="#深度优先遍历">深度优先遍历</a>
          <ol>
            <li><a href="#递归的算法思想">递归的算法思想</a></li>
          </ol>
        </li>
        <li><a href="#广度优先遍历">广度优先遍历</a></li>
        <li><a href="#图的遍历应用举例">图的遍历应用举例</a></li>
      </ol>
    </li>
    <li><a href="#图的连通性问题联通分量与最小生成树">图的连通性问题（联通分量与最小生成树）</a>
      <ol>
        <li><a href="#无向图的联通分量和生成树">无向图的联通分量和生成树</a>
          <ol>
            <li><a href="#连通图的生成树">连通图的生成树</a></li>
            <li><a href="#非连通图的生成森林">非连通图的生成森林</a></li>
          </ol>
        </li>
        <li><a href="#最小生成树">最小生成树</a>
          <ol>
            <li><a href="#prim算法">Prim算法</a></li>
            <li><a href="#kruskal算法">Kruskal算法</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#有向无环图及其应用拓补排序关键路径">有向无环图及其应用（拓补排序、关键路径）</a>
      <ol>
        <li><a href="#aov网与拓扑排序">AOV网与拓扑排序</a></li>
        <li><a href="#关键路径">关键路径</a></li>
      </ol>
    </li>
    <li><a href="#最短路径">最短路径</a>
      <ol>
        <li><a href="#dijkstra算法">Dijkstra算法</a></li>
        <li><a href="#floyd算法">Floyd算法</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="background-color: #2a9d8f; color: #fff;">
                数据结构
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/post/6-%E5%9B%BE/">6 图</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-01-22</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 15 分钟
                </time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-pencil" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
  <path d="M13.5 6.5l4 4" />
</svg>
                <time class="article-words">
                    字数: 7181 字
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="图">图<a hidden class="anchor" aria-hidden="true" href="#图">#</a></h1>
<h2 id="图的定义和术语">图的定义和术语<a hidden class="anchor" aria-hidden="true" href="#图的定义和术语">#</a></h2>
<h3 id="定义">定义<a hidden class="anchor" aria-hidden="true" href="#定义">#</a></h3>
<p>是由顶点集合和一个描述顶点之间关系&mdash;-边的集合组成</p>
<p>Graph=(V,E)</p>
<p>V：顶点(数据元素)的有穷非空集合。</p>
<p>E：边的有穷集合。</p>
<h3 id="相关术语">相关术语<a hidden class="anchor" aria-hidden="true" href="#相关术语">#</a></h3>
<blockquote>
<p>看这个不如看离散</p>
</blockquote>
<p><strong>顶点</strong>(Vertex):数据元素所构成的结点。</p>
<p><strong>弧(Arc)</strong>：顶点关系集合中的一个元素&lt;i,j&gt;,表示从顶点i到顶点j的一条弧。</p>
<p><strong>有向图</strong>(Digraph):弧(Arc)的顶点偶对是有序的。</p>
<p>对弧&lt;vi,vj&gt;而言，vi是<strong>弧尾</strong>(Tail)/初始点；vj是<strong>弧头</strong>(Head)/终端点。</p>
<p><strong>无向图</strong>(Undigraph)：弧的顶点偶对是无序的。</p>
<p>(vi, vj)和(vj, vi)代表同一条<strong>边</strong>(Edge)(i$\neq$j)。</p>
<p><strong>(无向)完全图</strong>  每个顶点与其余顶点都有边的无向图。</p>
<p>​         顶点数为n时，边数 <strong>e=n(n-1)/2</strong></p>
<p><strong>有向完全图</strong>  每个顶点与其余顶点都有弧的有向图。</p>
<p>​         顶点数为n时，弧数 <strong>e=n(n-1)</strong></p>
<p><strong>稀疏图</strong>(Sparse graph)  有很少边或弧的图。（e&lt;nlogn）</p>
<p><strong>稠密图</strong>(Dense graph)  有较多边或弧的图。</p>
<p><strong>顶点的度</strong>(Degree)  与该顶点相关联的边的数目，记为D(v)。</p>
<p>​    <strong>入度</strong>ID(v)：有向图中，以该顶点为弧头的弧数目。</p>
<p>​    <strong>出度</strong>OD(v)：有向图中，以该顶点为弧尾的弧数目。</p>
<p>顶点数n、边数e和度数之间的关系:</p>
<p>$e=\frac{1}{2} \sum_{i=1}^n D\left(v_i\right)$</p>
<p><strong>邻接</strong>  有边/弧相连的<strong>两个顶点</strong>之间的关系。</p>
<p>​     存在(vi, vj)，则称vi和vj互为<strong>邻接点</strong>(Adjacent)；</p>
<p>​     存在&lt;vi, vj&gt;，则称vi<strong>邻接到</strong>vj， vj<strong>邻接于</strong>vi</p>
<p>**关联(依附)边/**弧与顶点之间的关系。</p>
<p>​      存在(vi, vj)/ &lt;vi, vj&gt;， 则称该边/弧关联于vi和vj</p>
<p><strong>权(Weight)</strong>  图中的边或弧具有一定的大小的概念。</p>
<p><strong>网(Network)</strong> 边/弧带权的图。</p>
<p><strong>路径</strong>  接续的边构成的顶点序列。</p>
<p><strong>路径长度</strong>  路径上边或弧的数目/权值之和。</p>
<p><strong>回路(环)</strong>  第一个顶点和最后一个顶点相同的路径。</p>
<p><strong>简单路径</strong>  序列中顶点均不相同的路径。</p>
<p><strong>简单回路(简单环)</strong>  除路径起点和终点相同外，其余顶点均不相同的路径。</p>
<p><strong>连通</strong>：无向图中若从顶点V到顶点V’存在路径，则称V和V’是连通的。</p>
<p><strong>连通图</strong>  <strong>无向图</strong>中，任何一对顶点间都存在路径。</p>
<p><strong>连通分量</strong>  无向图中的极大连通子图。</p>
<p><strong>强连通图</strong>  <strong>有向图</strong>中，任何一对顶点间都存在路径。</p>
<p><strong>强连通分量</strong>  有向图中的极大连通子图。</p>
<p><strong>子图</strong>   对于图G=(V,E)和G’=(V’,E’)，如果V’V，E’ E，且E’关联的顶点都在V’中，则称G’是G的子图。</p>
<p><strong>生成子图</strong>  由图的<strong>全部顶点</strong>和<strong>部分边</strong>组成的子图称为原图的生成子图。</p>
<p><strong>生成树</strong>  包含图中<strong>全部顶点</strong>的<strong>极小连通</strong>子图。</p>
<p>一棵有n个顶点的生成树有且仅有n-1条边，如果一个图有n个顶点和小于n-1条边，则是非连通图。如果它多于n-1条边，则一定有环。但是，有n-1条边的图不一定是生成树。</p>
<p><strong>有向树</strong>  如果一个有向图中恰有一个顶点入度为0，其余顶点入度均为1。</p>
<p><strong>生成森林</strong>  有向图中，包含所有顶点的若干棵有向树构成的子图。</p>
<h3 id="图的基本操作">图的基本操作<a hidden class="anchor" aria-hidden="true" href="#图的基本操作">#</a></h3>
<p>(1)图的生成       CreatGraph(&amp;G, V,VR)</p>
<p>(2)销毁图        DestroyGraph(&amp;G)</p>
<p>(3)顶点定位       LocateVex(G,value)</p>
<p>(4)取顶点数据     Getvex(G,v)</p>
<p>(5)对顶点赋值     Putvex(&amp;G, v, value)</p>
<p>(6)求第一个邻接顶点   FirstAdjVex(G,v)</p>
<p>(7)求下一个邻接顶点   NextAdjVex(G,v,w)</p>
<p>(8)插入顶点       InsertVex(&amp;G,v)</p>
<p>(9)删除顶点       DeleteVex(&amp;G,v)</p>
<p>(10)插入边/弧     InsertArc(&amp;G,v,w)</p>
<p>(11)删除边/弧     DeleteArc(&amp;G,v,w)</p>
<p>(12)图的遍历      Traverse(G)</p>
<h2 id="图的存储结构">图的存储结构<a hidden class="anchor" aria-hidden="true" href="#图的存储结构">#</a></h2>
<h3 id="1数组邻接矩阵-表示法adjacency-matrix顺序存储方式">1.数组/邻接矩阵 表示法(Adjacency Matrix)顺序存储方式<a hidden class="anchor" aria-hidden="true" href="#1数组邻接矩阵-表示法adjacency-matrix顺序存储方式">#</a></h3>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221203213409802.png"
	
	
	
	loading="lazy"
	
		alt="image-20221203213409802"
	
	
></p>
<p>[存储结构定义]</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define INFINITY INT_MAX      </span><span class="c1">// 最大值 无穷
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MAX_VERTEX_NUM 20     </span><span class="c1">// 最大顶点个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">enum</span><span class="p">{</span><span class="n">DG</span><span class="p">,</span> <span class="n">DN</span><span class="p">,</span> <span class="n">UDG</span><span class="p">,</span> <span class="n">UDN</span><span class="p">}</span> <span class="n">GraphKind</span><span class="p">;</span>      <span class="c1">// 四种图类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">ArcCell</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="n">VRType</span> <span class="n">adj</span><span class="p">;</span>               <span class="c1">// 顶点关系类型。如带权图，则为权值类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="n">InfoType</span> <span class="o">*</span><span class="n">info</span> <span class="p">;</span>          <span class="c1">// 该弧的相关信息指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">ArcCell</span><span class="p">,</span> <span class="n">AdjMatrix</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">][</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">VertexType</span> <span class="n">vexs</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>      <span class="c1">// 顶点向量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AdjMatrix</span> <span class="n">arcs</span><span class="p">;</span>                       <span class="c1">// 邻接矩阵
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">vexnum</span><span class="p">,</span><span class="n">arcnum</span><span class="p">;</span>                    <span class="c1">// 图的当前顶点数和弧数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">GraphKind</span> <span class="n">kind</span><span class="p">;</span>                       <span class="c1">// 图的种类标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">MGraph</span><span class="p">;</span>
</span></span></code></pre></div><p>[算法示例]     建立无向网的数组型存储结构</p>
<p>步骤:</p>
<ol>
<li>
<p><code>scanf(顶点数n，边数e) </code>                    O(1)</p>
</li>
<li>
<p>依次读入每个顶点数据，填入顶点表vexs     O(n)</p>
</li>
<li>
<p>邻接矩阵arcs初始化：全部置∞；主对角线置0；                  O(n2)</p>
</li>
<li>
<p>建立邻接矩阵：                          O(e)</p>
<ol>
<li>读入一条边的两个顶点编号i、j和权值w</li>
<li>置<code>arcs[i][j]=w， arcs[j][i]=w</code></li>
<li>若尚有未读入的边，转4.1)</li>
</ol>
</li>
</ol>
<p>​                                                                                                  O(n2)</p>
<h4 id="邻接矩阵存储方法的特点">邻接矩阵存储方法的特点<a hidden class="anchor" aria-hidden="true" href="#邻接矩阵存储方法的特点">#</a></h4>
<p>①无向图的邻接矩阵一定是一个对称矩阵。</p>
<p>②对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的度TD(vi)。</p>
<p>③对于有向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的出度OD(vi)（或入度ID(vi)）。</p>
<p>④用邻接矩阵方法存储图，很容易确定图中任意两个顶点之间是否有边相连；但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。这是用邻接矩阵存储图的局限性。</p>
<h3 id="2邻接表adjacency-list-----顺序存储链式存储">2.邻接表(Adjacency List)     顺序存储+链式存储<a hidden class="anchor" aria-hidden="true" href="#2邻接表adjacency-list-----顺序存储链式存储">#</a></h3>
<p>邻接表(Adjacency List)是图的一种顺序存储与链式存储结合的存储方法。</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221203214055663.png"
	
	
	
	loading="lazy"
	
		alt="image-20221203214055663"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221203214124230.png"
	
	
	
	loading="lazy"
	
		alt="image-20221203214124230"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221203214207040.png"
	
	
	
	loading="lazy"
	
		alt="image-20221203214207040"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221203214243085.png"
	
	
	
	loading="lazy"
	
		alt="image-20221203214243085"
	
	
></p>
<h4 id="有向图的逆邻接表">有向图的逆邻接表<a hidden class="anchor" aria-hidden="true" href="#有向图的逆邻接表">#</a></h4>
<p>若邻接表的边结点链表建立的是以vi为头的弧链表，这样的邻接表称为逆邻接表。逆邻接表便于确定顶点的入度或以顶点vi为头的弧。</p>
<p>下图所示为有向图G2的邻接表和逆邻接表。</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221203214650291.png"
	
	
	
	loading="lazy"
	
		alt="image-20221203214650291"
	
	
></p>
<p>[存储结构定义]</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define MAX_VERTEX_NUM   20                    </span><span class="c1">// 最大顶点个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">enum</span><span class="p">{</span><span class="n">DG</span><span class="p">,</span> <span class="n">DN</span><span class="p">,</span> <span class="n">UDG</span><span class="p">,</span> <span class="n">UDN</span><span class="p">}</span> <span class="n">GraphKind</span><span class="p">;</span>      <span class="c1">// 四种图类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span>  <span class="n">ArcNode</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="kt">int</span> <span class="n">adjvex</span><span class="p">;</span>                         <span class="c1">// 该弧所指向的顶点的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="k">struct</span> <span class="n">ArcNode</span> <span class="o">*</span> <span class="n">nextarc</span> <span class="p">;</span>          <span class="c1">//指向下一条弧的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="kt">int</span> <span class="n">weight</span><span class="err">；</span>                        <span class="c1">//权值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="n">InfoType</span> <span class="o">*</span> <span class="n">info</span><span class="p">;</span>                    <span class="c1">//该弧的其它相关信息的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">ArcNode</span><span class="err">；</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VNode</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="n">VertexType</span> <span class="n">data</span><span class="p">;</span>                <span class="c1">// 顶点信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="n">ArcNode</span> <span class="o">*</span> <span class="n">firstarc</span> <span class="p">;</span>          <span class="c1">//指向第一条依附该顶点的弧的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">VNode</span><span class="p">,</span> <span class="n">AdjList</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span>   <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">AdjList</span> <span class="n">vertices</span><span class="p">;</span>                        <span class="c1">// 顶点向量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">vexnum</span><span class="p">,</span> <span class="n">arcnum</span><span class="p">;</span>                  <span class="c1">// 图的当前顶点数和弧数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">GraphKind</span> <span class="n">kind</span><span class="p">;</span>                          <span class="c1">// 图的种类标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">ALGraph</span><span class="p">;</span>
</span></span></code></pre></div><p>[算法示例]   建立无向网的邻接表表示</p>
<p>步骤：</p>
<p>\1) scanf(顶点数n，边数e)                       O(1)</p>
<p>\2) 依次读入每个顶点数据，</p>
<p>填入顶点表vertices的相应位置                O(n)</p>
<p>\3) 建立边表：                                O(e)</p>
<p>3.1) 读入一条边的两个顶点编号i、j和权值w</p>
<p>3.2) 申请边表结点，adjvex域=j，weight域=w，</p>
<p>​      将此结点插入顶点vi的边表头部</p>
<p>3.3) 申请边表结点，adjvex域=i，weight域=w，</p>
<p>​      将此结点插入顶点vj的边表头部</p>
<p>若尚有未读入的边，转3.1)</p>
<p>​</p>
<p>​                                     O(n+e)</p>
<p>[两种常用存储结构的比较]</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221203215027760.png"
	
	
	
	loading="lazy"
	
		alt="image-20221203215027760"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221203215132304.png"
	
	
	
	loading="lazy"
	
		alt="image-20221203215132304"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221203215151124.png"
	
	
	
	loading="lazy"
	
		alt="image-20221203215151124"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221203215204994.png"
	
	
	
	loading="lazy"
	
		alt="image-20221203215204994"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221203215218462.png"
	
	
	
	loading="lazy"
	
		alt="image-20221203215218462"
	
	
></p>
<h2 id="图的遍历">图的遍历<a hidden class="anchor" aria-hidden="true" href="#图的遍历">#</a></h2>
<img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221204134925985.png" alt="image-20221204134925985" style="zoom:50%;" />
<h3 id="深度优先遍历">深度优先遍历<a hidden class="anchor" aria-hidden="true" href="#深度优先遍历">#</a></h3>
<blockquote>
<p>树的先根遍历的推广</p>
</blockquote>
<p>①首先访问图中某一指定的出发点V</p>
<p>②以V的一个未访问过的邻接点W为新的出发点，</p>
<p>重复① 、②</p>
<p>③若邻接点都已访问过，则退回到前一顶点</p>
<p>④直到图中所有的顶点都被访问过。</p>
<h4 id="递归的算法思想">递归的算法思想<a hidden class="anchor" aria-hidden="true" href="#递归的算法思想">#</a></h4>
<p>(1)访问顶点v，并记录v已被访问</p>
<p>(2)依次从v的未访问的邻接点出发，深度优先搜索图G。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Boolean</span> <span class="n">visited</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>  <span class="c1">//辅助访问标志向量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">DFS</span><span class="p">(</span><span class="n">Graph</span> <span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">){</span>  
</span></span><span class="line"><span class="cl">    <span class="nf">visit</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>    
</span></span><span class="line"><span class="cl">    <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">TRUE</span><span class="p">;</span>  <span class="c1">//访问顶点v，并标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="nf">FirstAdjVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">);</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">w</span><span class="o">=</span><span class="nf">NextAdjVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>  <span class="nf">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">w</span><span class="p">);</span><span class="c1">//依次从未访问的邻接点出发
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// DFS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">DFS</span><span class="p">(</span><span class="n">MGraph</span> <span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//深度优先遍历邻接矩阵表示的图   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">visit</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">vexs</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>    
</span></span><span class="line"><span class="cl"> 	<span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">TRUE</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    	<span class="k">if</span><span class="p">(</span> <span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span>  <span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>  <span class="nf">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// DFS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">DFS</span><span class="p">(</span><span class="n">ALGraph</span> <span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">//深度优先遍历邻接表表示的图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>      
</span></span><span class="line"><span class="cl">    <span class="nf">visit</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>    
</span></span><span class="line"><span class="cl">    <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">TRUE</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">=</span><span class="n">G</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">firstarc</span><span class="p">;</span>    <span class="c1">//取v边表的头指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">visited</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">]</span> <span class="p">)</span>  
</span></span><span class="line"><span class="cl">            <span class="nf">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nextarc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// DFS
</span></span></span></code></pre></div><p>当图分连通时，需要多次启动DFS，每启动一次对应一个连通分量</p>
<img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221204140236514.png" alt="image-20221204140236514" style="zoom:33%;" />
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span>  <span class="nf">DFSTraverse</span><span class="p">(</span><span class="n">Graph</span> <span class="n">G</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>     <span class="k">for</span> <span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">              <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">FALSE</span><span class="p">;</span>  <span class="c1">//标志向量初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">for</span> <span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">             <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="p">)</span>  <span class="nf">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// DFSTraverse
</span></span></span></code></pre></div><p>[非递归的算法思想]
(1)访问一个顶点，并记录它已被访问；
将它的所有未访问的邻接顶点入栈；
(2)如果栈空，则退出；
否则，栈中一顶点出栈；
(3)如果该顶点已被访问过，则转(2)
否则，转(1)</p>
<p>[算法时间复杂度分析]
主要操作：查找每个顶点的所有邻接点
邻接矩阵   O(n2)
邻接表 O(n+e)          无向图结点数n+2e
有向图结点数n+e</p>
<h3 id="广度优先遍历">广度优先遍历<a hidden class="anchor" aria-hidden="true" href="#广度优先遍历">#</a></h3>
<blockquote>
<p>树的按层次遍历的推广</p>
</blockquote>
<p>(1)访问顶点v，并记录它已被访问；</p>
<p>​      顶点v入队列；</p>
<p>(2)如果队列空，则退出；</p>
<p>​     否则，从队中取出一顶点；</p>
<p>(3)求该顶点的一个邻接点；</p>
<p>​     如果此邻接点未被访问，</p>
<p>​     则访问它，并记录它已被访问，将其入队列；</p>
<p>(4)如果该顶点还有下一个邻接点，则转(3)；</p>
<p>​     否则，转(2)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">BFSTraverse</span><span class="p">(</span><span class="n">Graph</span> <span class="n">G</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span> <span class="c1">// 标志向量初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">InitQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span>             <span class="c1">// 辅助队列初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span> <span class="c1">// 从一个未访问的顶点开始启动BFS，每启动一次对应一个连通分量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="nf">visit</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                  <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="nf">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nf">QueueEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                  <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="nf">DeQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="k">for</span> <span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="nf">FirstAdjVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">                             <span class="n">w</span> <span class="o">=</span> <span class="nf">NextAdjVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                              <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                    <span class="nf">visit</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                    <span class="nf">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                              <span class="p">}</span>
</span></span><span class="line"><span class="cl">                  <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// BFSTraverse
</span></span></span></code></pre></div><p>深度优先遍历算法借助于栈结构实现；广度优先遍历算法借助于队列结构实现
图的遍历序列与算法和存储方式有关
对于非连通图，通过遍历可求得各连通分量</p>
<h3 id="图的遍历应用举例">图的遍历应用举例<a hidden class="anchor" aria-hidden="true" href="#图的遍历应用举例">#</a></h3>
<h2 id="图的连通性问题联通分量与最小生成树">图的连通性问题（联通分量与最小生成树）<a hidden class="anchor" aria-hidden="true" href="#图的连通性问题联通分量与最小生成树">#</a></h2>
<h3 id="无向图的联通分量和生成树">无向图的联通分量和生成树<a hidden class="anchor" aria-hidden="true" href="#无向图的联通分量和生成树">#</a></h3>
<h4 id="连通图的生成树">连通图的生成树<a hidden class="anchor" aria-hidden="true" href="#连通图的生成树">#</a></h4>
<p>生成树是G的一个子图，该子图是包含G的所有顶点的树</p>
<p>设G=(Vn,En) ，则从图中任一顶点进行遍历图时，必定将En分成两个集合T(G)和B(G)，其中T(G)是遍历时经过的边的集合，B(G)是剩余边的集合。显然T(G)和所有顶点一起构成连通图G的极小连通子图，也就是连通图的一棵生成树。</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221216181015492.png"
	
	
	
	loading="lazy"
	
		alt="image-20221216181015492"
	
	
></p>
<p>若图G有n个顶点，则其生成树必具有n-1条边。
生成树是包含图中所有顶点的极小连通子图。
生成树可以通过对图的深度/广度优先遍历而得到，称之为深度/广度优先生成树。
在算法中，访问一个结点时vj，同时记录它的父结点vi，(vi ,vj)是生成树的一条边。
一般情况，BFS(广度优先搜索)生成树的树高小于DFS(深度优先搜索)生成树的高度。
一个图的生成树是不唯一的
从不同的顶点出发
采用不同的存储结构和存储顺序</p>
<h4 id="非连通图的生成森林">非连通图的生成森林<a hidden class="anchor" aria-hidden="true" href="#非连通图的生成森林">#</a></h4>
<p>一个连通分量及其遍历时走过的边构成一棵生成树。
非连通图的各连通分量的生成树组成生成森林。</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221216181127037.png"
	
	
	
	loading="lazy"
	
		alt="image-20221216181127037"
	
	
></p>
<h3 id="最小生成树">最小生成树<a hidden class="anchor" aria-hidden="true" href="#最小生成树">#</a></h3>
<p>由一个网络生成的各边的权数总和最小的生成树，记为MST(Minimum Cost Spanning Tree)</p>
<p>MST性质 设$N=(V,{E})$是一个连通的网络，U是V的真子集，若边$(u,v)[u∈U,v∈V-U]$是E中所有一个端点在U内，一个端点不在U内的边中权值最小的<strong>质</strong>  一条边(轻边)，则一定存在G的一棵生成树包括此边。</p>
<h4 id="prim算法">Prim算法<a hidden class="anchor" aria-hidden="true" href="#prim算法">#</a></h4>
<p>Prim算法可用下述过程描述，其中用Wuv表示顶点u与顶点v边上的权值。</p>
<p>⑴ U＝{u1},T={};</p>
<p>⑵ while (U≠V)do</p>
<p>​    (u,v)＝min{Wuv|u∈U,v∈V－U } //(u,v)是最轻边</p>
<p>​    T＝T＋{(u,v)} //将(u,v)加入边集合</p>
<p>​    U＝U＋{v}  //将v加入顶点集合</p>
<p>⑶ 结束。</p>
<p>[算法步骤]</p>
<p>1)初始化<code>closedge[j](j=0..n-1)</code>           O(n)</p>
<p>2)重复n-1次以下操作：</p>
<p>2.1)在<code>closedge[j](j=0..n-1)</code>中选择最小且非0的lowcost，记录其j 值(设为k)和相应的adjvex；               O(n2)</p>
<p>2.2)输出该边(adjvex,k)；                 O(n)</p>
<p>2.3)顶点k并入U集：<code>closedge[k].lowcost=0</code>； O(n)</p>
<p>2.4)调整候选边集<code>closedge[j](j=0..n-1)</code>：      O(n2)</p>
<p>​      若<code>G.arcs[k][j] &lt; closedge[j].lowcost</code>，</p>
<p>​      则更改<code>closedge[j]：adjvex=k, lowcost=G.arcs[k][j]</code></p>
<p>​                                        O(n2)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Prim</span><span class="p">(</span><span class="n">MGraph</span> <span class="n">G</span><span class="p">,</span><span class="n">VertexType</span> <span class="n">u</span><span class="p">){</span>  
</span></span><span class="line"><span class="cl">    <span class="n">k</span><span class="o">=</span><span class="nf">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>       <span class="c1">//初始化辅助数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">closedge</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">adj</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>   <span class="c1">//进行G.vexnum-1次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">k</span><span class="o">=</span><span class="nf">minium</span><span class="p">(</span><span class="n">closedge</span><span class="p">);</span>           <span class="c1">//选择顶点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="n">closedge</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">adjvex</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">closedge</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">lowcost</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>        <span class="c1">//顶点k并入U集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>  <span class="c1">//调整候选边集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">adj</span><span class="o">&lt;</span><span class="n">closedge</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">lowcost</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">closedge</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">adj</span><span class="p">};</span> <span class="c1">//cost可以减小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="c1">//Prim
</span></span></span></code></pre></div><p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/prim.png"
	
	
	
	loading="lazy"
	
		alt="prim"
	
	
></p>
<p>初始化</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>顶点数组下标i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>adjvex</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>lowcost</td>
<td>0</td>
<td>6</td>
<td>1</td>
<td>5</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td>集合U:0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></div>
<p>添加第一条边</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>顶点数组下标i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>adjvex</td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>lowcost</td>
<td>0</td>
<td>5</td>
<td>0</td>
<td>5</td>
<td>6</td>
<td>4</td>
</tr>
<tr>
<td>集合U:0,2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></div>
<p>添加第二条边</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>顶点数组下标i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>adjvex</td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>5</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>lowcost</td>
<td>0</td>
<td>5</td>
<td>0</td>
<td>2</td>
<td>6</td>
<td>0</td>
</tr>
<tr>
<td>集合U:0,2,5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></div>
<p>添加第三条边</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>顶点数组下标i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>adjvex</td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>lowcost</td>
<td>0</td>
<td>5</td>
<td>0</td>
<td>0</td>
<td>6</td>
<td>0</td>
</tr>
<tr>
<td>集合U:0,2,5,3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></div>
<p>添加第四条边</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>顶点数组下标i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>adjvex</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>lowcost</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>0</td>
</tr>
<tr>
<td>集合U:0,2,3,5,1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></div>
<p>添加第五条边</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>顶点数组下标i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>adjvex</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>lowcost</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>集合U:0,2,3,5,1,4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></div>
<h4 id="kruskal算法">Kruskal算法<a hidden class="anchor" aria-hidden="true" href="#kruskal算法">#</a></h4>
<p>1)初始化T：顶点集=所有顶点，每个独立的顶点作为一棵树，边集=ø；</p>
<p>​                                              O(n)</p>
<p>\2) 依权值递增序对图G的边排序，结果为E[0..e-1]    O(eloge)</p>
<p>\3) 依次检测E中的各边(u,v)：                      O(eloge)</p>
<p>3.1) 若u和v分属于T中两棵不同的树，则将该边加入T，并合并u和v分属的两棵树</p>
<p>3.2) 若T中所有顶点尚未属于一棵树，转3)</p>
<p>其中3）可参阅教材139页“树与等价问题”</p>
<p>[算法特点]   适用于稀疏图</p>
<p><strong>关节点和重连通分量</strong></p>
<p>如果删去顶点v及和v相关联的各边之后，将图的一个连通分量分割成两个或两个以上的连通分量，则称顶点v为该图的一个关节点。
一个没有关节的点连通图称为重连通图。在重连通图上，任意一对顶点之间至少有两条路径。若在连通图上至少删去k个顶点才能破坏图的连通性，则称此图的连通度为k。</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221216181435969.png"
	
	
	
	loading="lazy"
	
		alt="image-20221216181435969"
	
	
></p>
<h2 id="有向无环图及其应用拓补排序关键路径">有向无环图及其应用（拓补排序、关键路径）<a hidden class="anchor" aria-hidden="true" href="#有向无环图及其应用拓补排序关键路径">#</a></h2>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221216181554625.png"
	
	
	
	loading="lazy"
	
		alt="image-20221216181554625"
	
	
></p>
<h3 id="aov网与拓扑排序">AOV网与拓扑排序<a hidden class="anchor" aria-hidden="true" href="#aov网与拓扑排序">#</a></h3>
<p>1．AOV网 (Activity On Vertex Network,顶点表示活动的网)
(1) AOV概念：顶点表示活动，弧表示活动之间存在的制约关系网称为AOV。
(2) 用AOV表示一个工程：</p>
<p>[问题目标]
当一个任务可以划分为若干个子任务/子活动/子事件，其中的任何子任务可能又以另外的一些子任务作为先决条件时，如何排定子任务的执行顺序，达到整体任务的完成。</p>
<p>[什么是拓扑排序]
按照有向图给出的次序关系，将图中顶点排成一个线性序列。
检查有向图中是否存在回路的方法之一，是对有向图进行拓扑排序。</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221216182808283.png"
	
	
	
	loading="lazy"
	
		alt="image-20221216182808283"
	
	
></p>
<p>[无前趋的顶点优先算法]</p>
<p>算法原理
在一个拓扑序列中，每个顶点必定出现在它的所有前趋顶点之后。
算法思想</p>
<ol>
<li>
<p>选择一个入度为0的顶点(无前趋的顶点)，输出它</p>
</li>
<li>
<p>删去该顶点及其关联的所有出边
重复上述两步，直至图中不再有入度为0的顶点为止。
若所有顶点均被输出，则排序成功，
否则图中存在有向环。</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221216182904414.png"
	
	
	
	loading="lazy"
	
		alt="image-20221216182904414"
	
	
></p>
</li>
</ol>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221216182919040.png"
	
	
	
	loading="lazy"
	
		alt="image-20221216182919040"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221216182933495.png"
	
	
	
	loading="lazy"
	
		alt="image-20221216182933495"
	
	
></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">TopologicalSort</span><span class="p">(</span><span class="n">ALGraph</span> <span class="n">G</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">FindInDegree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">indegree</span><span class="p">);</span> <span class="c1">// 求各顶点入度indegree[G.vexnum]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">InitStack</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                  <span class="nf">push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nf">StackEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">pop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">printf</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">firstarc</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nextarc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span> <span class="c1">// 修改入度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">--</span><span class="n">indegree</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">                        <span class="nf">push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="c1">// 若入度为0则入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// TopologicalSort
</span></span></span></code></pre></div><p>[无后继的顶点优先]</p>
<p>算法原理
在一个拓扑序列中，每个顶点必定出现在它的所有后继顶点之前。
方法一
（按逆拓扑次序生成顶点序列）</p>
<ol>
<li>选择一个出度为0的顶点(无后继的顶点)，输出它</li>
<li>删去该顶点及其关联的所有入边
重复上述两步，直至图中不再有出度为0的顶点为止。
若所有顶点均被输出，则排序成功，
否则图中存在有向环。</li>
</ol>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221216183020434.png"
	
	
	
	loading="lazy"
	
		alt="image-20221216183020434"
	
	
></p>
<p>方法二    利用深度优先遍历        （从入度为0的顶点出发）</p>
<p>1)访问顶点v，并记录v已被访问
2)依次从v的未访问的邻接点出发，深度优先
拓扑排序图G。
3)输出顶点v（此时v相当于无后继的顶点）</p>
<p>注意：此方法仅适用于有向无环图
（此算法不能检测出有向环，得到虚假拓扑序列）</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221216183104519.png"
	
	
	
	loading="lazy"
	
		alt="image-20221216183104519"
	
	
></p>
<h3 id="关键路径">关键路径<a hidden class="anchor" aria-hidden="true" href="#关键路径">#</a></h3>
<p>1．AOE网（ Activity On Eege Network，边表示活动的网）
(1) AOE网概念：若在带权的有向图中，以顶点表示事件，以有向边表示活动，边上的权值表示活动的开销（如该活动持续的时间），则此带权的有向图称为AOE网。
(2)AOE网表示一项工程能表示出：
①完成预定工程计划所需要进行的活动;
②每个活动计划完成的时间;
③要发生哪些事件以及这些事件与活动之间的关系;</p>
<p>(3) 通过AOE网可以求得：
①估算工程完成的时间
②确定哪些活动是影响工程进度的关键。</p>
<p>(4) AOE网的两个特点：
①只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始。
②只有在进入一某顶点的各有向边所代表的活动都已经结束，该顶点所代表的事件才能发生。</p>
<p>[相关概念和术语]
源点   入度为0的顶点，即工程的开始点
汇点   出度为0的顶点，即工程的完成点
关键路径   从源点到汇点的最长路径
关键路径长度=最短工期
关键活动   关键路径上的活动
关键活动的加快可以缩短工期
[确定关键路径时涉及的几个变量]
e(i) :活动ai的最早开始时间
l(i) :活动ai的最迟开始时间
ve(j) :事件vj的最早发生时间
vl(j) :事件vj的最迟发生时间</p>
<img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221216183246367.png" alt="image-20221216183246367" style="zoom:50%;" />
<p>为了在AOE网中找出关键路径，需要定义几个参量：
(1)事件的最早发生时间ve[k] :定义为从V1到事件Vk的最长路径
(2)事件的最迟发生时间vl[k]:不拖延整个工期的情况下，最迟发生时间
(3)活动ai的最早开始时间e[i]:该活动的弧尾事件的最早发生时间
(4)活动ai的最晚开始时间l[i]：不拖延整个工期的情况下，最晚时间</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/Screenshot_20221216_214639.jpg"
	
	
	
	loading="lazy"
	
		alt="Screenshot_20221216_214639"
	
	
></p>
<p>算法描述</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">TopologicalOrder</span><span class="p">(</span><span class="n">ALGraph</span> <span class="n">G</span><span class="p">,</span> <span class="n">Stack</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 计算各顶点的最早发生时间ve(全局变量)，并用栈T返回G的一个拓扑序列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">FindInDegree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">indegree</span><span class="p">);</span> <span class="c1">// 求各顶点入度indegree[G.vexnum]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">InitStack</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">ve</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 初始化为0，栈S用来辅助求拓扑序列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                  <span class="nf">push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// 入度为0的入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">InitStack</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nf">StackEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">pop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">push</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">firstarc</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nextarc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">--</span><span class="n">indegree</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">                        <span class="nf">push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="c1">// 入度-1后若为0则入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="k">if</span> <span class="p">(</span><span class="n">ve</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                        <span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ve</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">);</span> <span class="c1">// 更新ve[k]，求max
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// TopologicalOrder
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">CriticalPath</span><span class="p">(</span><span class="n">ALGraph</span> <span class="n">G</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// G为有向网，输出G的各项关键活动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">TopologicalOrder</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">vl</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span> <span class="n">G</span><span class="p">.</span><span class="n">vexnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ve</span><span class="p">[</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nf">StackEmpty</span><span class="p">(</span><span class="n">T</span><span class="p">))</span> <span class="c1">// 按拓扑逆序求各顶点的vl值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="nf">pop</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">p</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">firstarc</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nextarc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="p">(</span><span class="n">vl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">vl</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                        <span class="n">vl</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">vl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">);</span> <span class="c1">// 更新vl，求min
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="c1">// 求各活动的ee、el和确定关键活动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">firstarc</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nextarc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="n">dut</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="n">ee</span> <span class="o">=</span> <span class="n">ve</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                  <span class="n">el</span> <span class="o">=</span> <span class="n">vl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">dut</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">ee</span> <span class="o">==</span> <span class="n">el</span><span class="p">)</span> <span class="o">?</span> <span class="err">’</span><span class="o">*</span><span class="err">’</span> <span class="o">:</span><span class="err">’</span> <span class="err">’</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="nf">printf</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dut</span><span class="p">,</span> <span class="n">ee</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// CriticalPath
</span></span></span></code></pre></div><h2 id="最短路径">最短路径<a hidden class="anchor" aria-hidden="true" href="#最短路径">#</a></h2>
<h3 id="dijkstra算法">Dijkstra算法<a hidden class="anchor" aria-hidden="true" href="#dijkstra算法">#</a></h3>
<p>设源点为v0，求到其余各顶点的最短路径，记录权值</p>
<p>再从v0邻接的顶点出发，寻找并更新最短路径。</p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/%25E5%25BE%25AE%25E4%25BF%25A1%25E5%259B%25BE%25E7%2589%2587_20221217145455.jpg"
	
	
	
	loading="lazy"
	
		alt="微信图片_20221217145455"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221217150043404.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221217150240850.png"
	
	
	
	loading="lazy"
	
		alt="image-20221217150240850"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221217150308704.png"
	
	
	
	loading="lazy"
	
		alt="image-20221217150308704"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221217150320901.png"
	
	
	
	loading="lazy"
	
		alt="image-20221217150320901"
	
	
></p>
<p>[教材189页算法7.15]</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">ShortestPath_DIJ</span><span class="p">(</span><span class="n">Mgraph</span> <span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">PathMatrix</span> <span class="o">&amp;</span><span class="n">P</span><span class="p">,</span> <span class="n">ShortPathTable</span> <span class="o">&amp;</span><span class="n">D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">vexnum</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">final</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">v0</span><span class="p">][</span><span class="n">v</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">vexnum</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="n">P</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">INFINITY</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="n">P</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">v0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">D</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">final</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vexnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">min</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">vexnum</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">final</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">D</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">k</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">min</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">w</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                  <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">final</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*考虑新加入的节点k */</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">vexnum</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">final</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">min</span> <span class="o">+</span> <span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">w</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">                  <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">D</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span> <span class="o">+</span> <span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">w</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                        <span class="n">P</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                        <span class="n">P</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="floyd算法">Floyd算法<a hidden class="anchor" aria-hidden="true" href="#floyd算法">#</a></h3>
<blockquote>
<p>每一对顶点之间的最短路径</p>
</blockquote>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221217150515898.png"
	
	
	
	loading="lazy"
	
		alt="image-20221217150515898"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/image-20221217150547416.png"
	
	
	
	loading="lazy"
	
		alt="image-20221217150547416"
	
	
></p>
<p><img src="https://picture2023-1309715649.cos.ap-beijing.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221217153810.jpg"
	
	
	
	loading="lazy"
	
		alt="微信图片_20221217153810"
	
	
></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">ShortestPath_FLOYD1</span><span class="p">(</span><span class="n">Mgraph</span> <span class="n">G</span><span class="p">,</span> <span class="n">PathMatrix</span> <span class="o">&amp;</span><span class="n">Path</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                         <span class="n">DistanceMatrix</span> <span class="o">&amp;</span><span class="n">D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">];</span> <span class="c1">// 初始化D(-1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="n">path</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="err"></span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">INFINITY</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="n">path</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">w</span><span class="p">];</span> <span class="c1">// 初始化直接路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="c1">// 依次引入中间顶点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="k">for</span> <span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span> <span class="c1">// 如果经过中间点k能优化长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                              <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">w</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                              <span class="n">Path</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">Path</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">Path</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">w</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// ShortestPath_FLOYD1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">ShortestPath_FLOYD2</span><span class="p">(</span><span class="n">Mgraph</span> <span class="n">G</span><span class="p">,</span> <span class="n">PathMatrix</span> <span class="o">&amp;</span><span class="n">P</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                         <span class="n">DistanceMatrix</span> <span class="o">&amp;</span><span class="n">D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// P[v][w][k]为TRUE，则从v到w的最短路径中含有k节点
</span></span></span><span class="line"><span class="cl"><span class="c1">// D[v][w]从v到w的最短路径的长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                  <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="n">p</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">INFINITY</span><span class="p">)</span>               <span class="c1">// 存在直接路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">P</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span> <span class="c1">// 从v到w的路径中包括v和w
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="c1">// 依次加入中间顶点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="k">for</span> <span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span> <span class="c1">// 如果经过中间点k能优化长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                              <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">w</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                              <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">P</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                              <span class="c1">// v经k到w的路径包含的节点为v到k的路径节点 || k到w的路径节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// ShortestPath_FLOYD2        P191-算法7.16
</span></span></span></code></pre></div>
</section>


    <footer class="article-footer">
    

    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.8/katex.min.css"crossorigin="anonymous"
            ><script 
                src="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.8/katex.min.js"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.8/contrib/auto-render.min.js"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
        &copy; 
        
        2024 Bethel<br>共 200.85k 字 · 共 24 篇文章
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://stack.jimmycai.com/" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> 由 <a href="https://jimmycai.com/" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script><script type="text/javascript" src="/ts/custom.js" defer></script>


<script src="https://mecdn.mcserverx.com/gh/zhixuan2333/gh-blog/master/js/nprogress.min.js" integrity="sha384-bHDlAEUFxsRI7JfULv3DTpL2IXbbgn4JHQJibgo5iiXSK6Iu8muwqHANhun74Cqg" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://mecdn.mcserverx.com/gh/zhixuan2333/gh-blog/master/css/nprogress.css" integrity="sha384-KJyhr2syt5+4M9Pz5dipCvTrtvOmLk/olWVdfhAp858UCa64Ia5GFpTN7+G4BWpE" crossorigin="anonymous" />
<script>
    NProgress.start();
    document.addEventListener("readystatechange", () => {
        if (document.readyState === "interactive") NProgress.inc(0.8);
        if (document.readyState === "complete") NProgress.done();
    });
</script>
    </body>
</html>
